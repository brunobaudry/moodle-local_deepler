{"version":3,"file":"scrollspy.min.js","sources":["../../src/local/scrollspy.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Port of the scrollspy script from Angelika Cathor (angelikatyborska) to AMD.\n * Utilizes the scroll event to update the breadcrumbs based on the current scroll position.\n *\n * @module     local_deepler/deepler\n * @file       amd/src/local/scrollspy.js\n * @copyright  2025 Bruno Baudry <bruno.baudry@bfh.ch>\n * @copyright  2025 Angelika Cathor <https://angelika.me>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n * @see https://github.com/angelikatyborska\n */\ndefine([], () => {\n    let OFFSET_TOP;\n    let ARTICLE;\n    let CONTAINER;\n    let END_OF_ARTICLE;\n    let HIGHEST_LEVEL;\n    let FADING_DISTANCE;\n    let OFFSET_END_OF_SCOPE;\n    /**\n     * Injects the breadcrumbs into the container.\n     *\n     * @param {array} headingsPerLevel\n     */\n    const makeBreadcrumbs = (headingsPerLevel)=>{\n        CONTAINER.innerHTML = getBreadcrumbs(headingsPerLevel, scrollTop());\n        if (CONTAINER.innerHTML.trim() === '') {\n            CONTAINER.style.display = 'none';\n        } else {\n            CONTAINER.style.display = 'block';\n        }\n    };\n\n    /**\n     * Returns the current scroll position.\n     */\n    const scrollTop = ()=>{\n        return window.scrollY + OFFSET_TOP;\n    };\n\n    /**\n     * Returns an array of headings per level.\n     */\n    const getHeadingsPerLevel = ()=> {\n        const headingsPerLevel = [];\n        for (let level = HIGHEST_LEVEL; level <= 6; level++) {\n            let headings = Array.prototype.slice.call(ARTICLE.querySelectorAll('span.h' + level));\n            headings = headings.sort((a, b)=> b.offsetTop - a.offsetTop);\n            headingsPerLevel.push(headings);\n        }\n\n        return headingsPerLevel;\n    };\n\n    /**\n     * Gets the breadcrumbs at position.\n     *\n     * @param {array} headingsPerLevel\n     * @param {number} scrollTop\n     * @return {string}\n     */\n    const getBreadcrumbs = (headingsPerLevel, scrollTop)=> {\n        const breadcrumbs = [];\n        const headingsInScope = findHeadingsInScope(headingsPerLevel, scrollTop);\n\n        headingsInScope.forEach((heading)=> {\n            const opacity = calculateOpacity(heading.beginningOfScope, heading.endOfScope, scrollTop);\n            const html = '<a href=\"#' + heading.id\n                + '\" class=\"' + heading.tag\n                + '\" style=\"opacity:' + opacity\n                + '; pointer-events: ' + (opacity > 0.5 ? 'auto' : 'none')\n                + '\">' + heading.text\n                + '</a>';\n\n            breadcrumbs.push(html);\n        });\n        return breadcrumbs.join('<small>&nbsp;&gt;&nbsp;</small>');\n    };\n\n    /**\n     * Finds the headings in scope.\n     *\n     * @param {array} headingsPerLevel\n     * @param {number} scrollTop\n     * @return {string}\n     */\n    const findHeadingsInScope = (headingsPerLevel, scrollTop) =>{\n        const headingsInScope = [];\n        let previousHeadingOffset = 0;\n\n        headingsPerLevel.forEach((headings, level)=> {\n            const heading = headings.find((node) =>{\n                return node.offsetTop < scrollTop && node.offsetTop > previousHeadingOffset;\n            });\n            if (heading) {\n                const nextHeadingOfSameLevel = headingsPerLevel[level][headingsPerLevel[level].indexOf(heading) - 1];\n                const currentHeadingOfHigherLevel = headingsInScope[headingsInScope.length - 1];\n                const endOfScope = calculateEndOfScope(nextHeadingOfSameLevel, currentHeadingOfHigherLevel);\n\n                headingsInScope.push({\n                    id: heading.id,\n                    tag: heading.tagName.toLowerCase(),\n                    text: heading.textContent.trim(),\n                    beginningOfScope: heading.offsetTop + heading.offsetHeight,\n                    endOfScope: endOfScope\n                });\n\n                previousHeadingOffset = heading.offsetTop;\n            } else {\n                previousHeadingOffset = END_OF_ARTICLE;\n            }\n        });\n\n        return headingsInScope;\n    };\n\n    /**\n     * Calculates the end of the scope.\n     *\n     * @param {object} nextHeadingOfSameLevel\n     * @param {object} currentHeadingOfHigherLevel\n     * @return {number}\n     */\n    const calculateEndOfScope = (nextHeadingOfSameLevel, currentHeadingOfHigherLevel) => {\n        let endOfScope;\n\n        if (currentHeadingOfHigherLevel) {\n            if (nextHeadingOfSameLevel) {\n                endOfScope = Math.min(nextHeadingOfSameLevel.offsetTop, currentHeadingOfHigherLevel.endOfScope);\n            } else {\n                endOfScope = currentHeadingOfHigherLevel.endOfScope;\n            }\n        } else {\n            if (nextHeadingOfSameLevel) {\n                endOfScope = nextHeadingOfSameLevel.offsetTop;\n            } else {\n                endOfScope = END_OF_ARTICLE;\n            }\n        }\n\n        return endOfScope;\n    };\n\n    /**\n     * Calculates the opacity of the breadcrumb.\n     *\n     * @param {number} top\n     * @param {number} bottom\n     * @param {number} scrollTop\n     */\n    const calculateOpacity = (top, bottom, scrollTop) =>{\n        const diffTop = scrollTop - top;\n        const topOnFade = diffTop / FADING_DISTANCE;\n        const opacityTop = diffTop > FADING_DISTANCE ? 1 : diffTop / topOnFade;\n        const diffBottom = bottom - scrollTop - OFFSET_END_OF_SCOPE;\n        const bottomOnFade = diffBottom / FADING_DISTANCE;\n        const opacityBottom = diffBottom > FADING_DISTANCE ? 1 : bottomOnFade;\n        return Math.min(opacityTop, opacityBottom);\n    };\n    const init = (article, breadcrumbsContainer, options) =>{\n        ARTICLE = document.querySelector(article);\n        CONTAINER = document.querySelector(breadcrumbsContainer);\n        END_OF_ARTICLE = ARTICLE.offsetTop + ARTICLE.offsetHeight;\n        HIGHEST_LEVEL = options.highestLevel || 2;\n        FADING_DISTANCE = options.fadingDistance == 0 ? 1 : options.fadingDistance || 100;\n        OFFSET_END_OF_SCOPE = options.offsetEndOfScope || 100;\n        OFFSET_TOP = options.offsetTop || 0;\n        const headingsPerLevel = getHeadingsPerLevel();\n        makeBreadcrumbs(headingsPerLevel);\n        window.addEventListener('scroll', () =>{\n            makeBreadcrumbs(headingsPerLevel);\n        });\n    };\n    return {\n        init: init\n    };\n});\n"],"names":["define","OFFSET_TOP","ARTICLE","CONTAINER","END_OF_ARTICLE","HIGHEST_LEVEL","FADING_DISTANCE","OFFSET_END_OF_SCOPE","makeBreadcrumbs","headingsPerLevel","innerHTML","getBreadcrumbs","scrollTop","trim","style","display","window","scrollY","breadcrumbs","findHeadingsInScope","forEach","heading","opacity","calculateOpacity","beginningOfScope","endOfScope","html","id","tag","text","push","join","headingsInScope","previousHeadingOffset","headings","level","find","node","offsetTop","nextHeadingOfSameLevel","indexOf","currentHeadingOfHigherLevel","length","calculateEndOfScope","tagName","toLowerCase","textContent","offsetHeight","Math","min","top","bottom","diffTop","opacityTop","diffBottom","opacityBottom","init","article","breadcrumbsContainer","options","document","querySelector","highestLevel","fadingDistance","offsetEndOfScope","Array","prototype","slice","call","querySelectorAll","sort","a","b","getHeadingsPerLevel","addEventListener"],"mappings":";;;;;;;;;;;AA0BAA,uCAAO,IAAI,SACHC,WACAC,QACAC,UACAC,eACAC,cACAC,gBACAC,0BAMEC,gBAAmBC,mBACrBN,UAAUO,UAAYC,eAAeF,iBAAkBG,aACpB,KAA/BT,UAAUO,UAAUG,OACpBV,UAAUW,MAAMC,QAAU,OAE1BZ,UAAUW,MAAMC,QAAU,SAO5BH,UAAY,IACPI,OAAOC,QAAUhB,WAwBtBU,eAAiB,CAACF,iBAAkBG,mBAChCM,YAAc,UACIC,oBAAoBV,iBAAkBG,WAE9CQ,SAASC,gBACfC,QAAUC,iBAAiBF,QAAQG,iBAAkBH,QAAQI,WAAYb,WACzEc,KAAO,aAAeL,QAAQM,GAC9B,YAAcN,QAAQO,IACtB,oBAAsBN,QACtB,sBAAwBA,QAAU,GAAM,OAAS,QACjD,KAAOD,QAAQQ,KACf,OAENX,YAAYY,KAAKJ,SAEdR,YAAYa,KAAK,oCAUtBZ,oBAAsB,CAACV,iBAAkBG,mBACrCoB,gBAAkB,OACpBC,sBAAwB,SAE5BxB,iBAAiBW,SAAQ,CAACc,SAAUC,eAC1Bd,QAAUa,SAASE,MAAMC,MACpBA,KAAKC,UAAY1B,WAAayB,KAAKC,UAAYL,2BAEtDZ,QAAS,OACHkB,uBAAyB9B,iBAAiB0B,OAAO1B,iBAAiB0B,OAAOK,QAAQnB,SAAW,GAC5FoB,4BAA8BT,gBAAgBA,gBAAgBU,OAAS,GACvEjB,WAAakB,oBAAoBJ,uBAAwBE,6BAE/DT,gBAAgBF,KAAK,CACjBH,GAAIN,QAAQM,GACZC,IAAKP,QAAQuB,QAAQC,cACrBhB,KAAMR,QAAQyB,YAAYjC,OAC1BW,iBAAkBH,QAAQiB,UAAYjB,QAAQ0B,aAC9CtB,WAAYA,aAGhBQ,sBAAwBZ,QAAQiB,eAEhCL,sBAAwB7B,kBAIzB4B,iBAULW,oBAAsB,CAACJ,uBAAwBE,mCAC7ChB,kBAIIA,WAFJgB,4BACIF,uBACaS,KAAKC,IAAIV,uBAAuBD,UAAWG,4BAA4BhB,YAEvEgB,4BAA4BhB,WAGzCc,uBACaA,uBAAuBD,UAEvBlC,eAIdqB,YAULF,iBAAmB,CAAC2B,IAAKC,OAAQvC,mBAC7BwC,QAAUxC,UAAYsC,IAEtBG,WAAaD,QAAU9C,gBAAkB,EAAI8C,SADjCA,QAAU9C,iBAEtBgD,WAAaH,OAASvC,UAAYL,oBAElCgD,cAAgBD,WAAahD,gBAAkB,EADhCgD,WAAahD,uBAE3B0C,KAAKC,IAAII,WAAYE,sBAgBzB,CACHC,KAfS,CAACC,QAASC,qBAAsBC,WACzCzD,QAAU0D,SAASC,cAAcJ,SACjCtD,UAAYyD,SAASC,cAAcH,sBACnCtD,eAAiBF,QAAQoC,UAAYpC,QAAQ6C,aAC7C1C,cAAgBsD,QAAQG,cAAgB,EACxCxD,gBAA4C,GAA1BqD,QAAQI,eAAsB,EAAIJ,QAAQI,gBAAkB,IAC9ExD,oBAAsBoD,QAAQK,kBAAoB,IAClD/D,WAAa0D,QAAQrB,WAAa,QAC5B7B,iBA5HkB,YAClBA,iBAAmB,OACpB,IAAI0B,MAAQ9B,cAAe8B,OAAS,EAAGA,QAAS,KAC7CD,SAAW+B,MAAMC,UAAUC,MAAMC,KAAKlE,QAAQmE,iBAAiB,SAAWlC,QAC9ED,SAAWA,SAASoC,MAAK,CAACC,EAAGC,IAAKA,EAAElC,UAAYiC,EAAEjC,YAClD7B,iBAAiBqB,KAAKI,iBAGnBzB,kBAoHkBgE,GACzBjE,gBAAgBC,kBAChBO,OAAO0D,iBAAiB,UAAU,KAC9BlE,gBAAgBC"}