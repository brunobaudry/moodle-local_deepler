{"version":3,"file":"translation.min.js","sources":["../../src/local/translation.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n\n/**\n * @module     local_deepler/deepler\n * @file       amd/src/local/translation.js\n * @copyright  2025 Bruno Baudry <bruno.baudry@bfh.ch>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\ndefine([\n    'core/log', './api', './utils', './selectors', './tokeniser', './customevents'],\n    (Log, Api, Utils, Selectors, Tokeniser, Events) => {\n    let tempTranslations = {};\n    let escapePatterns = {};\n    let mainSourceLang = \"\";\n    let deeplSourceLang = \"\";\n    let targetLang = \"\";\n    let moodleTargetToSave = \"\";\n    let courseid = 0;\n    let userid = 0;\n    let settings = {};\n    let settingsRephrase = {};\n    let rephrasesymbol = '';\n    const ON_ITEM_TRANSLATED = 'onItemTranslated';\n    // Const ON_ITEM_NOT_TRANSLATED = 'onItemsNotTranslated';\n    const ON_ITEM_SAVED = 'onItemSaved';\n    const ON_ITEM_NOT_SAVED = 'onItemNotSaved';\n    const ON_TRANSLATION_FAILED = 'onTranslationFailed';\n    const ON_REPHRASE_FAILED = 'onRephraseFailed';\n    const ON_DB_SAVE_SUCCESS = 'onDbSuccess';\n    const ON_DB_FAILED = 'onDbFailed';\n    const setMainLangs = (config) => {\n        Log.debug(`translation/x/setMainLangs::config`);\n        Log.debug(config);\n        if (config.currentlang !== undefined && config.currentlang !== '') {\n            mainSourceLang = config.currentlang;\n        }\n        if (config.targetlang !== undefined && config.targetlang !== '') {\n            targetLang = config.targetlang.toLowerCase();\n        }\n        if (config.deeplsourcelang !== undefined && config.deeplsourcelang !== '') {\n            deeplSourceLang = config.deeplsourcelang.toLowerCase();\n        }\n    };\n    const onTrDbSuccess = (data)=>{\n        Log.info(data);\n        if (data.length === 0) {\n            Events.emit(ON_DB_FAILED, 'no data returned', '');\n        } else {\n            const errors = data.filter((item) => item.error !== '');\n            data.forEach((item) => {\n                if (item.error === '') {\n                    // Refreshing the text in the temp obbject in case of new translation without page refresh.\n                    tempTranslations[item.keyid].fieldText = item.text;\n                    Events.emit(ON_ITEM_SAVED, item.keyid, item.text);\n                } else {\n                    Events.emit(ON_ITEM_NOT_SAVED, item.keyid, item.error);\n                }\n            });\n            Events.emit(ON_DB_SAVE_SUCCESS, errors);\n        }\n    };\n    /**\n     * Translation DB failed.\n     * @param {int} status\n     * @param {string} error\n     */\n    const onTrDbFailed = (status, error) =>{\n            Events.emit(ON_DB_FAILED, error, status);\n            Log.trace(status);\n            Log.trace(error);\n        };\n    /**\n     * Save translations to the DB.\n     * @param {array} items\n     * @param {object} config\n     */\n    const saveTranslations = (items, config) => {\n        const data = items.map(item => prepareDbUpdateItem(item, config.userPrefs === 'textarea'));\n        Log.debug(`translation/x/saveTranslations::data`);\n        Log.debug(data);\n        Events.on(Api.TR_DB_SUCCESS, onTrDbSuccess);\n        Events.on(Api.TR_DB_FAILED, onTrDbFailed);\n        Api.updateTranslationsInDb(data, userid, courseid);\n    };\n        /**\n         * Prepare the data to be saved in the DB.\n         * @param {object} item\n         * @param {boolean} maineditorIsTextArea\n         * @returns {{ id, tid: *, field, table, text: string}}\n         */\n        const prepareDbUpdateItem = (item, maineditorIsTextArea) => {\n            const key = item.key;\n            Log.debug(tempTranslations[key]);\n            // Const textTosave = getupdatedtext(key, maineditorIsTextArea);\n            const textTosave = getEditorText(tempTranslations[key].editor, maineditorIsTextArea);\n            Log.debug(`translation/x/prepareDbUpdateItem::textTosave`);\n            Log.debug(textTosave);\n            Log.debug(tempTranslations[key]);\n            Log.debug(mainSourceLang);\n            Log.debug(deeplSourceLang);\n            Log.debug(moodleTargetToSave);\n            // TextTosave = getEditorText(key, maineditorIsTextArea);\n            return {\n                id: item.id,\n                tid: item.tid,\n                field: item.field,\n                table: item.table,\n                text: getEditorText(tempTranslations[key].editor, maineditorIsTextArea),\n                cmid: item.cmid,\n                keyid: key,\n                mainsourcecode: mainSourceLang,\n                sourcecode: tempTranslations[key].sourceLang,\n                targetcode: document.querySelector(Selectors.actions.targetCompatibleSwitcher).value,\n                sourcetext: getSourceText(key)\n            };\n        };\n        /**\n         * Update Textarea.\n         *\n         * @param {string} key\n         * @param {boolean} maineditorIsTextArea\n         * @returns {string}\n         * translation.js\n         *\n        const getupdatedtext = (key, maineditorIsTextArea) => {\n            const sourceItemLang = tempTranslations[key].sourceLang.toLowerCase().replace(rephrasesymbol, '');\n            const fieldText = tempTranslations[key].fieldText; // Translation\n            Log.debug(`translation/x/getupdatedtext::fieldText`);\n            Log.debug(fieldText);\n            const translation = getEditorText(tempTranslations[key].editor, maineditorIsTextArea);// Translation\n            const source = getSourceText(key);// Translation\n            const isFirstTranslation = fieldText.indexOf(\"{mlang\") === -1;\n            const isSourceOther = sourceItemLang === deeplSourceLang;\n            Log.debug(`translation/x/getupdatedtext::mainSourceLang`);\n            Log.debug(mainSourceLang);\n            Log.debug(sourceItemLang);\n            Log.debug(isSourceOther);\n            const selectedTarget = moodleTargetToSave;\n            const selectedTargetLangRoot = selectedTarget.toLowerCase().substring(0, 2);\n            Log.debug(`translation/x/getupdatedtext::selectedTarget`);\n            Log.debug(selectedTarget);\n            Log.debug(selectedTargetLangRoot);\n            const tagPatterns = {\n                \"other\": \"({mlang other)(.*?){mlang}\",\n                \"target\": `({mlang ${selectedTarget}}(.*?){mlang})`,\n                \"source\": `({mlang ${sourceItemLang}}(.*?){mlang})`\n            };\n            const langsItems = {\n                \"fullContent\": fieldText,\n                \"other\": `{mlang other}${source}{mlang}`,\n                \"target\": `{mlang ${selectedTarget}}${translation}{mlang}`,\n                \"source\": `{mlang ${sourceItemLang}}${source}{mlang}`\n            };\n            if (isFirstTranslation) {\n                // No mlang tag : easy.\n                if (selectedTargetLangRoot === sourceItemLang) {\n                    return translation;\n                } else if (isSourceOther) {\n                    return langsItems.other + langsItems.target;\n                } else {\n                    return langsItems.other + langsItems.source + langsItems.target;\n                }\n            }\n            // Alreaddy mlang tag-s.\n            return additionalUpdate(isSourceOther, tagPatterns, langsItems);\n        };\n         */\n        /**\n         * Update Textarea when there was mlang tags.\n         * Main regex '({mlang ([a-z]{2,5})}(.*?){mlang})'.\n         * @param {boolean} isSourceOther\n         * @param {string} tagPatterns\n         * @param {string} langsItems\n         * @returns {string} {string}\n         * @todo MDL-000 refactor this.\n         *\n        const additionalUpdate = (isSourceOther, tagPatterns, langsItems) => {\n            Log.debug(`translation/x/additionalUpdate::langsItems`);\n            Log.debug(langsItems);\n            let manipulatedText = langsItems.fullContent;\n            // Do we have a TARGET tag already ?\n            const targetReg = new RegExp(tagPatterns.target, \"sgi\");\n            const hasTagTarget = manipulatedText.match(targetReg);\n            if (hasTagTarget) {\n                // Yes replace it.\n                manipulatedText = manipulatedText.replace(targetReg, Tokeniser.escapeReplacementString(langsItems.target));\n            } else {\n                // No, add it at the end.\n                const lastMlangClosingTagEnd = manipulatedText.lastIndexOf(\"{mlang}\") + \"{mlang}\".length;\n                manipulatedText = [manipulatedText.slice(0, lastMlangClosingTagEnd),\n                    langsItems.target,\n                    manipulatedText.slice(lastMlangClosingTagEnd)\n                ].join('');\n            }\n            // Do we have a OTHER tag already ?\n            const otherReg = new RegExp(tagPatterns.other, \"sgi\");\n            const hasTagOther = manipulatedText.match(otherReg);\n            // Do we have a SOURCE tag already ?\n            const sourceReg = new RegExp(tagPatterns.other, \"sgi\");\n            const hasTagSource = manipulatedText.match(sourceReg);\n            if (isSourceOther) {\n                // Whatever was the {mlang other} tag language we need to replace it by this source.\n                manipulatedText = manipulatedText.replace(otherReg, Tokeniser.escapeReplacementString(langsItems.other));\n                if (hasTagSource) {\n                    // And remove the {mlang source} tag if found.\n                    manipulatedText.replace(sourceReg, \"\");\n                }\n            } else {\n                if (!hasTagOther) {\n                    // We still add this source as otherTag of the so that it can be replaced further.\n                    const firstMlangClosingTagEnd = manipulatedText.indexOf(\"{mlang\");\n                    manipulatedText = [manipulatedText.slice(0, firstMlangClosingTagEnd),\n                        langsItems.other,\n                        manipulatedText.slice(firstMlangClosingTagEnd)\n                    ].join('');\n                }\n                if (!hasTagSource) {\n                    // Add the {mlang source} tag if not found.\n                    manipulatedText.replace(sourceReg, Tokeniser.escapeReplacementString(langsItems.source));\n                }\n            }\n            return manipulatedText;\n        };\n         */\n        /**\n         * Editor's text content.\n         *\n         * @param {HTMLElement} editor\n         * @param {boolean} maineditorIsTextArea\n         * @returns {string}\n         * translation.js\n         */\n        const getEditorText = (editor, maineditorIsTextArea) => {\n            let text = editor.innerHTML;\n            if (maineditorIsTextArea) {\n                text = Utils.decodeHTML(text);\n            }\n            return text;\n        };\n        /**\n         * Source text de-tokenised.\n         *\n         * @param {String} key\n         * @returns {String}\n         * translation.js\n         */\n        const getSourceText = (key) => {\n            const sourceTokenised = tempTranslations[key].source;\n            return Tokeniser.postprocess(sourceTokenised, tempTranslations[key].tokens);\n        };\n    /**\n     * Initializing object storage before translation.\n     * @param {string} key\n     * @param {editor: object, editorType: string} editorSettings\n     * @param {string} sourceTextEncoded\n     * @param {string} multilangRawTextEncoded\n     * @param {string} sourceLang\n     */\n    const initTempForKey = (key, editorSettings, sourceTextEncoded, multilangRawTextEncoded, sourceLang) => {\n        const sourceText = Utils.fromBase64(sourceTextEncoded);\n        const fieldText = Utils.fromBase64(multilangRawTextEncoded);\n        const tokenised = Tokeniser.preprocess(sourceText, escapePatterns, escapePatterns);\n        tempTranslations[key] = {\n            editorType: editorSettings.editorType,\n            editor: editorSettings.editor,\n            source: tokenised.tokenizedText,\n            sourceLang: sourceLang,\n            fieldText: fieldText,\n            status: Selectors.statuses.wait,\n            translation: '',\n            tokens: tokenised.expressions\n        };\n    };\n    /**\n     * Wipe pout the temp.\n     * @param {string} key\n     */\n    const initTemp = (key)=>{\n        tempTranslations[key] = {\n            editorType: null,\n            editor: null,\n            source: '',\n            sourceLang: '',\n            fieldText: '',\n            status: '',\n            translation: '',\n            tokens: []\n        };\n    };\n        /**\n         * Prepare the texts for the external api calls.\n         *\n         * @param {string} key\n         * @returns {{text, source_lang: (string|string|*), key}}\n         */\n    const prepareTranslation = (key) => {\n        return {\n            text: tempTranslations[key].source,\n            // eslint-disable-next-line camelcase\n            source_lang: tempTranslations[key].sourceLang,\n            key: key\n        };\n    };\n    /**\n     * Call the external translation service to translate the selected keys.\n     *\n     * @param {array} keys\n     * @param {object} config\n     * @return void\n     */\n    const callTranslations = (keys, config) => {\n        rephrasesymbol = config.rephrasesymbol;\n        const translations = [];\n        const rephrases = [];\n        prepareAdvancedSettings(targetLang, config);\n        // We parse and check if it is a tranlsation or text improvment.\n        keys.forEach((key) => {\n            const t = prepareTranslation(key);\n            if (config.canimprove && t.source_lang.includes(rephrasesymbol)) {\n                delete t.source_lang;\n                Log.debug(`translation/x/callTranslations::t`);\n                Log.debug(t);\n                rephrases.push(t);\n            } else {\n                translations.push(t);\n            }\n        });\n        if (translations.length > 0) {\n            Events.on(Api.DEEPL_SUCCESS, onTranslateSuccess);\n            Events.on(Api.DEEPL_FAILED, onTranslateFailed);\n             Api.translate(translations, settings, Api.APP_VERSION);\n        }\n        if (rephrases.length > 0) {\n            Events.on(Api.DEEPL_RF_SUCCESS, onRephraseSuccess);\n            Events.on(Api.DEEPL_RF_FAILED, onRephaseFailed);\n            Api.rephrase(rephrases, settingsRephrase, Api.APP_VERSION);\n        }\n    };\n    const onTranslateSuccess = (response)=>{\n        Log.info(`translation//onTranslateSuccess::response`);\n        Log.info(response);\n        response.forEach((tr) => {\n            if (tr.error === '') {\n                let key = tr.key;\n                let translation = Tokeniser.postprocess(tr.translated_text, tempTranslations[key].tokens);\n                tempTranslations[key].editor.innerHTML = translation;\n                tempTranslations[key].translation = translation;\n                Events.emit(ON_ITEM_TRANSLATED, key);\n            } else {\n                Events.emit(ON_TRANSLATION_FAILED, tr.error);\n            }\n        });\n    };\n    const onRephraseSuccess = (response)=>{\n        response.forEach((tr) => {\n            if (tr.error === '') {\n                let key = tr.key;\n                let rephrase = Tokeniser.postprocess(tr.text, tempTranslations[key].tokens);\n                tempTranslations[key].editor.innerHTML = rephrase;\n                tempTranslations[key].translation = rephrase;\n                Events.emit(ON_ITEM_TRANSLATED, key);\n            } else {\n                Events.emit(ON_REPHRASE_FAILED, tr.error);\n            }\n        });\n    };\n    const onTranslateFailed = (status, error)=>{\n        Events.emit(ON_TRANSLATION_FAILED, status, error);\n    };\n    const onRephaseFailed = (status, error)=>{\n        Events.emit(ON_REPHRASE_FAILED, status, error);\n    };\n    /**\n     * Compile Advanced settings.\n     *\n     * @param {string} targetLang\n     * @param {object} config\n     * @returns {{}}\n     * translation.js ok\n     */\n    const prepareAdvancedSettings = (targetLang, config) => {\n        escapePatterns.LATEX = document.querySelector(Selectors.actions.escapeLatex).checked;\n        escapePatterns.PRETAG = document.querySelector(Selectors.actions.escapePre).checked;\n        // eslint-disable-next-line camelcase\n        settings.tag_handling = document.querySelector(Selectors.deepl.tagHandling).checked ? 'html' : 'xml';//\n        settings.context = document.querySelector(Selectors.deepl.context).value ?? null;//\n        // eslint-disable-next-line camelcase\n        settings.split_sentences = document.querySelector(Selectors.deepl.splitSentences).value;//\n        // eslint-disable-next-line camelcase\n        settings.preserve_formatting = document.querySelector(Selectors.deepl.preserveFormatting).checked;//\n        settings.formality = document.querySelector('[name=\"local_deepler/formality\"]:checked').value;\n        // eslint-disable-next-line camelcase\n        settings.glossary_id = document.querySelector(Selectors.deepl.glossaryId).value;//\n        if (settings.glossary_id !== '') {\n            Utils.setCookie(Utils.COOKIE_PREFIX + mainSourceLang + targetLang + courseid, settings.glossary_id, 703);\n        }\n        // eslint-disable-next-line camelcase\n        settings.outline_detection = document.querySelector(Selectors.deepl.outlineDetection).checked;//\n        // eslint-disable-next-line camelcase\n        settings.non_splitting_tags = Utils.toJsonArray(document.querySelector(Selectors.deepl.nonSplittingTags).value);\n        // eslint-disable-next-line camelcase\n        settings.splitting_tags = Utils.toJsonArray(document.querySelector(Selectors.deepl.splittingTags).value);\n        // eslint-disable-next-line camelcase\n        settings.ignore_tags = Utils.toJsonArray(document.querySelector(Selectors.deepl.ignoreTags).value);\n        // eslint-disable-next-line camelcase\n        settings.model_type = document.querySelector(Selectors.deepl.modelType).value ?? 'prefer_quality_optimized';\n        // eslint-disable-next-line camelcase\n        settings.show_billed_characters = true;\n        // eslint-disable-next-line camelcase\n        settings.target_lang = targetLang.toUpperCase();\n        if (config.canimprove) {\n            settingsRephrase.target_lang = settings.target_lang;\n            settingsRephrase.toneorstyle = document.querySelector(Selectors.deepl.toneorstyle).value ?? 'default';\n        }\n    };\n    /**\n     * Check if the item is translatable.\n     * @todo MDL-0000 implement in v1.4.0 (return based on local source)\n     * @param {string} sourceLang\n     */\n    const isTranslatable = (sourceLang = '') =>{\n         Log.info(targetLang, sourceLang, targetLang === (sourceLang === '' ? mainSourceLang : sourceLang));\n        // Return targetLang !== (sourceLang === '' ? mainSourceLang : sourceLang);\n        return targetLang !== '';\n    };\n        const translated = (key)=>{\n            return tempTranslations[key]?.translation?.length > 0;\n        };\n        const debugTemp = (key)=>{\n            Log.debug(`translation/x/debugTemp::key`);\n            Log.debug(key);\n            Log.debug(tempTranslations[key]);\n        };\n        const init = (cfg) => {\n            Api.APP_VERSION = cfg.version;\n            courseid = cfg.courseid;\n            userid = cfg.userid;\n            setMainLangs(cfg);\n        };\n        return {\n            init: init,\n            debugTemp: debugTemp,\n            callTranslations: callTranslations,\n            saveTranslations: saveTranslations,\n            initTempForKey: initTempForKey,\n            initTemp: initTemp,\n            moodleTargetToSave: moodleTargetToSave,\n            ON_ITEM_TRANSLATED: ON_ITEM_TRANSLATED,\n            ON_DB_FAILED: ON_DB_FAILED,\n            ON_ITEM_SAVED: ON_ITEM_SAVED,\n            ON_ITEM_NOT_SAVED: ON_ITEM_NOT_SAVED,\n            ON_TRANSLATION_FAILED: ON_TRANSLATION_FAILED,\n            ON_REPHRASE_FAILED: ON_REPHRASE_FAILED,\n            ON_DB_SAVE_SUCCESS: ON_DB_SAVE_SUCCESS,\n            setMainLangs: setMainLangs,\n            isTranslatable: isTranslatable,\n            translated: translated\n    };\n});\n"],"names":["define","Log","Api","Utils","Selectors","Tokeniser","Events","tempTranslations","escapePatterns","mainSourceLang","deeplSourceLang","targetLang","courseid","userid","settings","settingsRephrase","rephrasesymbol","setMainLangs","config","debug","undefined","currentlang","targetlang","toLowerCase","deeplsourcelang","onTrDbSuccess","data","info","length","emit","errors","filter","item","error","forEach","keyid","fieldText","text","onTrDbFailed","status","trace","prepareDbUpdateItem","maineditorIsTextArea","key","textTosave","getEditorText","editor","id","tid","field","table","cmid","mainsourcecode","sourcecode","sourceLang","targetcode","document","querySelector","actions","targetCompatibleSwitcher","value","sourcetext","getSourceText","innerHTML","decodeHTML","sourceTokenised","source","postprocess","tokens","onTranslateSuccess","response","tr","translation","translated_text","onRephraseSuccess","rephrase","onTranslateFailed","onRephaseFailed","prepareAdvancedSettings","LATEX","escapeLatex","checked","PRETAG","escapePre","tag_handling","deepl","tagHandling","context","split_sentences","splitSentences","preserve_formatting","preserveFormatting","formality","glossary_id","glossaryId","setCookie","COOKIE_PREFIX","outline_detection","outlineDetection","non_splitting_tags","toJsonArray","nonSplittingTags","splitting_tags","splittingTags","ignore_tags","ignoreTags","model_type","modelType","show_billed_characters","target_lang","toUpperCase","canimprove","toneorstyle","init","cfg","APP_VERSION","version","debugTemp","callTranslations","keys","translations","rephrases","t","source_lang","prepareTranslation","includes","push","on","DEEPL_SUCCESS","DEEPL_FAILED","translate","DEEPL_RF_SUCCESS","DEEPL_RF_FAILED","saveTranslations","items","map","userPrefs","TR_DB_SUCCESS","TR_DB_FAILED","updateTranslationsInDb","initTempForKey","editorSettings","sourceTextEncoded","multilangRawTextEncoded","sourceText","fromBase64","tokenised","preprocess","editorType","tokenizedText","statuses","wait","expressions","initTemp","moodleTargetToSave","ON_ITEM_TRANSLATED","ON_DB_FAILED","ON_ITEM_SAVED","ON_ITEM_NOT_SAVED","ON_TRANSLATION_FAILED","ON_REPHRASE_FAILED","ON_DB_SAVE_SUCCESS","isTranslatable","translated"],"mappings":"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"}