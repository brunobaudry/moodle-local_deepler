{"version":3,"file":"translation.min.js","sources":["../../src/local/translation.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n\n/**\n * @module     local_deepler/deepler\n * @file       amd/src/local/translation.js\n * @copyright  2025 Bruno Baudry <bruno.baudry@bfh.ch>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\ndefine([\n    'core/log', './api', './utils', './selectors', './tokeniser', './customevents'],\n    (Log, Api, Utils, Selectors, Tokeniser, Events) => {\n    let tempTranslations = {};\n    let escapePatterns = {};\n    let mainSourceLang = \"\";\n    let deeplSourceLang = \"\";\n    let targetLang = \"\";\n    let moodleTargetToSave = \"\";\n    let courseid = 0;\n    let userid = 0;\n    let rephrasesymbol = '';\n    const deeplSettinRegex = /\\[(name=\"local_deepler|data-id=\"local_deepler)\\/(\\w+)\"\\]/i;\n    const ON_ITEM_TRANSLATED = 'onItemTranslated';\n    // Const ON_ITEM_NOT_TRANSLATED = 'onItemsNotTranslated';\n    const ON_ITEM_SAVED = 'onItemSaved';\n    const ON_ITEM_NOT_SAVED = 'onItemNotSaved';\n    const ON_TRANSLATION_FAILED = 'onTranslationFailed';\n    const ON_REPHRASE_FAILED = 'onRephraseFailed';\n    const ON_DB_SAVE_SUCCESS = 'onDbSuccess';\n    const ON_DB_FAILED = 'onDbFailed';\n    const setMainLangs = (config) => {\n        Log.debug(`translation/x/setMainLangs::config`);\n        Log.debug(config);\n        if (config.currentlang !== undefined && config.currentlang !== '') {\n            mainSourceLang = config.currentlang;\n        }\n        if (config.targetlang !== undefined && config.targetlang !== '') {\n            targetLang = config.targetlang.toLowerCase();\n        }\n        if (config.deeplsourcelang !== undefined && config.deeplsourcelang !== '') {\n            deeplSourceLang = config.deeplsourcelang.toLowerCase();\n        }\n    };\n    const onTrDbSuccess = (data)=>{\n        Log.info(data);\n        if (data.length === 0) {\n            Events.emit(ON_DB_FAILED, 'no data returned', '');\n        } else {\n            const errors = data.filter((item) => item.error !== '');\n            data.forEach((item) => {\n                if (item.error === '') {\n                    // Refreshing the text in the temp obbject in case of new translation without page refresh.\n                    tempTranslations[item.keyid].fieldText = item.text;\n                    Events.emit(ON_ITEM_SAVED, item.keyid, item.text);\n                } else {\n                    Events.emit(ON_ITEM_NOT_SAVED, item.keyid, item.error);\n                }\n            });\n            Events.emit(ON_DB_SAVE_SUCCESS, errors);\n        }\n    };\n    /**\n     * Translation DB failed.\n     * @param {int} status\n     * @param {string} error\n     */\n    const onTrDbFailed = (status, error) =>{\n            Events.emit(ON_DB_FAILED, error, status);\n            Log.trace(status);\n            Log.trace(error);\n        };\n    /**\n     * Save translations to the DB.\n     * @param {array} items\n     * @param {object} config\n     */\n    const saveTranslations = (items, config) => {\n        const data = items.map(item => prepareDbUpdateItem(item, config.userPrefs === 'textarea'));\n        Log.debug(`translation/x/saveTranslations::data`);\n        Log.debug(data);\n        Events.on(Api.TR_DB_SUCCESS, onTrDbSuccess);\n        Events.on(Api.TR_DB_FAILED, onTrDbFailed);\n        Api.updateTranslationsInDb(data, userid, courseid);\n    };\n        /**\n         * Prepare the data to be saved in the DB.\n         *\n         * @param {object} item\n         * @param {boolean} maineditorIsTextArea\n         * @returns {{ id, tid: *, field, table, text: string}}\n         */\n        const prepareDbUpdateItem = (item, maineditorIsTextArea) => {\n            const key = item.key;\n            Log.debug(tempTranslations[key]);\n            // Const textTosave = getupdatedtext(key, maineditorIsTextArea);\n            const textTosave = getEditorText(tempTranslations[key].editor, maineditorIsTextArea);\n            Log.debug(`translation/x/prepareDbUpdateItem::textTosave`);\n            Log.debug(textTosave);\n            Log.debug(tempTranslations[key]);\n            Log.debug(mainSourceLang);\n            Log.debug(deeplSourceLang);\n            Log.debug(moodleTargetToSave);\n            // TextTosave = getEditorText(key, maineditorIsTextArea);\n            return {\n                tid: item.tid,\n                text: getEditorText(tempTranslations[key].editor, maineditorIsTextArea),\n                keyid: key,\n                mainsourcecode: mainSourceLang,\n                sourcecode: tempTranslations[key].sourceLang,\n                targetcode: document.querySelector(Selectors.actions.targetCompatibleSwitcher).value,\n                sourcetext: getSourceText(key)\n            };\n        };\n        /**\n         * Editor's text content.\n         *\n         * @param {HTMLElement} editor\n         * @param {boolean} maineditorIsTextArea\n         * @returns {string}\n         * translation.js\n         */\n        const getEditorText = (editor, maineditorIsTextArea) => {\n            let text = editor.innerHTML;\n            if (maineditorIsTextArea) {\n                text = Utils.decodeHTML(text);\n            }\n            return text;\n        };\n        /**\n         * Source text de-tokenised.\n         *\n         * @param {String} key\n         * @returns {String}\n         * translation.js\n         */\n        const getSourceText = (key) => {\n            const sourceTokenised = tempTranslations[key].source;\n            return Tokeniser.postprocess(sourceTokenised, tempTranslations[key].tokens);\n        };\n    /**\n     * Initializing object storage before translation.\n     *\n     * @param {string} key\n     * @param {editor: object, editorType: string} editorSettings\n     * @param {string} sourceTextEncoded\n     * @param {string} multilangRawTextEncoded\n     * @param {string} sourceLang\n     */\n    const initTempForKey = (key, editorSettings, sourceTextEncoded, multilangRawTextEncoded, sourceLang) => {\n        const sourceText = Utils.fromBase64(sourceTextEncoded);\n        const fieldText = Utils.fromBase64(multilangRawTextEncoded);\n        const tokenised = Tokeniser.preprocess(sourceText, escapePatterns);\n        tempTranslations[key] = {\n            editorType: editorSettings.editorType,\n            editor: editorSettings.editor,\n            source: tokenised.tokenizedText,\n            sourceLang: sourceLang,\n            fieldText: fieldText,\n            status: Selectors.statuses.wait,\n            translation: '',\n            tokens: tokenised.expressions\n        };\n    };\n    /**\n     * Wipe pout the temp.\n     * @param {string} key\n     */\n    const initTemp = (key)=>{\n        tempTranslations[key] = {\n            editorType: null,\n            editor: null,\n            source: '',\n            sourceLang: '',\n            fieldText: '',\n            status: '',\n            translation: '',\n            tokens: []\n        };\n    };\n    /**\n     * Prepare the texts for the external api calls.\n     *\n     * @param {string} key\n     * @returns {{text, source_lang: (string|string|*), key}}\n     */\n    const prepareTranslation = (key) => {\n        return {\n            text: tempTranslations[key].source,\n            // eslint-disable-next-line camelcase\n            source_lang: tempTranslations[key].sourceLang,\n            key: key\n        };\n    };\n    /**\n     * Call the external translation service to translate the selected keys.\n     *\n     * @param {array} keys\n     * @param {object} config\n     * @param {object} settings\n     * @return void\n     */\n    const callTranslations = (keys, config, settings) => {\n        rephrasesymbol = config.rephrasesymbol;\n        const translations = [];\n        const rephrases = [];\n        // We parse and check if it is a tranlsation or text improvment.\n        keys.forEach((key) => {\n            const t = prepareTranslation(key);\n            if (config.canimprove && t.source_lang.includes(rephrasesymbol)) {\n                delete t.source_lang;\n                Log.debug(`translation/x/callTranslations::t`);\n                Log.debug(t);\n                rephrases.push(t);\n            } else {\n                translations.push(t);\n            }\n        });\n        if (translations.length > 0) {\n            Events.on(Api.DEEPL_SUCCESS, onTranslateSuccess);\n            Events.on(Api.DEEPL_FAILED, onTranslateFailed);\n             Api.translate(translations, prepareTranslationSettings(settings), Api.APP_VERSION);\n        }\n        if (rephrases.length > 0) {\n            Events.on(Api.DEEPL_RF_SUCCESS, onRephraseSuccess);\n            Events.on(Api.DEEPL_RF_FAILED, onRephaseFailed);\n            Api.rephrase(rephrases, prepareRephraseSettings(settings), Api.APP_VERSION);\n        }\n    };\n    /**\n     * When translation went good.\n     *\n     * @param {object} response\n     */\n    const onTranslateSuccess = (response)=>{\n        Log.info(`translation//onTranslateSuccess::response`);\n        Log.info(response);\n        response.forEach((tr) => {\n            if (tr.error === '') {\n                let key = tr.key;\n                let translation = Tokeniser.postprocess(tr.translated_text, tempTranslations[key].tokens);\n                tempTranslations[key].editor.innerHTML = translation;\n                tempTranslations[key].translation = translation;\n                Events.emit(ON_ITEM_TRANSLATED, key);\n            } else {\n                Events.emit(ON_TRANSLATION_FAILED, tr.error);\n            }\n        });\n    };\n    /**\n     * When rephrasing went good.\n     *\n     * @param {object} response\n     */\n    const onRephraseSuccess = (response)=>{\n        response.forEach((tr) => {\n            if (tr.error === '') {\n                let key = tr.key;\n                let rephrase = Tokeniser.postprocess(tr.text, tempTranslations[key].tokens);\n                tempTranslations[key].editor.innerHTML = rephrase;\n                tempTranslations[key].translation = rephrase;\n                Events.emit(ON_ITEM_TRANSLATED, key);\n            } else {\n                Events.emit(ON_REPHRASE_FAILED, tr.error);\n            }\n        });\n    };\n    /**\n     * When translation failed.\n     *\n     * @param {int} status\n     * @param {string} error\n     */\n    const onTranslateFailed = (status, error)=>{\n        Events.emit(ON_TRANSLATION_FAILED, status, error);\n    };\n    /**\n     * Event handler for when the rephrase fails.\n     *\n     * @param {string} status\n     * @param {string} error\n     */\n    const onRephaseFailed = (status, error)=>{\n        Events.emit(ON_REPHRASE_FAILED, status, error);\n    };\n        /**\n         * Set up the Deepl settings needed for translations.\n         *\n         * @param {object} settings\n         * @returns {{}}\n         */\n    const prepareTranslationSettings = (settings)=>{\n        const trSelectors = [Selectors.deepl.tagHandling,\n            Selectors.deepl.context,\n            Selectors.deepl.splitSentences,\n            Selectors.deepl.preserveFormatting,\n            Selectors.deepl.formality,\n            Selectors.deepl.glossaryId,\n            Selectors.deepl.outlineDetection,\n            Selectors.deepl.nonSplittingTags,\n            Selectors.deepl.splittingTags,\n            Selectors.deepl.ignoreTags,\n            Selectors.deepl.modelType\n        ];\n        const s = filterSetting(settings, trSelectors);\n        s.target_lang = targetLang.toUpperCase();\n        s.show_billed_characters = true;\n        return s;\n    };\n        /**\n         * Set up the Deepl settings needed for rephrases.\n         * @param {object}  settings\n         * @returns {{}}\n         */\n    const prepareRephraseSettings = (settings)=>{\n        const rephraseSelectors = [Selectors.deepl.toneorstyle];\n        const s = filterSetting(settings, rephraseSelectors);\n        s.target_lang = targetLang.toUpperCase();\n        return s;\n    };\n        /**\n         * Filter the UI settings by Deepl service needed set.\n         * @param {object} settings\n         * @param {array}  selList\n         * @returns {{}}\n         */\n    const filterSetting = (settings, selList) =>{\n        const se = {};\n        for (let i in selList) {\n            const set = selList[i].match(deeplSettinRegex)[2];\n            se[set] = settings[selList[i]];\n        }\n        return se;\n    };\n    /**\n     * Check if the item is translatable.\n     * @todo MDL-0000 implement in v1.4.0 (return based on local source)\n     * @param {string} sourceLang\n     */\n    const isTranslatable = (sourceLang = '') =>{\n         Log.info(targetLang, sourceLang, targetLang === (sourceLang === '' ? mainSourceLang : sourceLang));\n        // Return targetLang !== (sourceLang === '' ? mainSourceLang : sourceLang);\n        return targetLang !== '';\n    };\n        const translated = (key)=>{\n            return tempTranslations[key]?.translation?.length > 0;\n        };\n        const debugTemp = (key)=>{\n            Log.debug(`translation/x/debugTemp::key`);\n            Log.debug(key);\n            Log.debug(tempTranslations[key]);\n        };\n        const init = (cfg) => {\n            Api.APP_VERSION = cfg.version;\n            courseid = cfg.courseid;\n            userid = cfg.userid;\n            setMainLangs(cfg);\n        };\n        return {\n            init: init,\n            debugTemp: debugTemp,\n            callTranslations: callTranslations,\n            saveTranslations: saveTranslations,\n            initTempForKey: initTempForKey,\n            initTemp: initTemp,\n            moodleTargetToSave: moodleTargetToSave,\n            ON_ITEM_TRANSLATED: ON_ITEM_TRANSLATED,\n            ON_DB_FAILED: ON_DB_FAILED,\n            ON_ITEM_SAVED: ON_ITEM_SAVED,\n            ON_ITEM_NOT_SAVED: ON_ITEM_NOT_SAVED,\n            ON_TRANSLATION_FAILED: ON_TRANSLATION_FAILED,\n            ON_REPHRASE_FAILED: ON_REPHRASE_FAILED,\n            ON_DB_SAVE_SUCCESS: ON_DB_SAVE_SUCCESS,\n            setMainLangs: setMainLangs,\n            isTranslatable: isTranslatable,\n            translated: translated\n    };\n});\n"],"names":["define","Log","Api","Utils","Selectors","Tokeniser","Events","tempTranslations","escapePatterns","mainSourceLang","deeplSourceLang","targetLang","courseid","userid","rephrasesymbol","deeplSettinRegex","setMainLangs","config","debug","undefined","currentlang","targetlang","toLowerCase","deeplsourcelang","onTrDbSuccess","data","info","length","emit","errors","filter","item","error","forEach","keyid","fieldText","text","onTrDbFailed","status","trace","prepareDbUpdateItem","maineditorIsTextArea","key","textTosave","getEditorText","editor","tid","mainsourcecode","sourcecode","sourceLang","targetcode","document","querySelector","actions","targetCompatibleSwitcher","value","sourcetext","getSourceText","innerHTML","decodeHTML","sourceTokenised","source","postprocess","tokens","onTranslateSuccess","response","tr","translation","translated_text","onRephraseSuccess","rephrase","onTranslateFailed","onRephaseFailed","prepareTranslationSettings","settings","trSelectors","deepl","tagHandling","context","splitSentences","preserveFormatting","formality","glossaryId","outlineDetection","nonSplittingTags","splittingTags","ignoreTags","modelType","s","filterSetting","target_lang","toUpperCase","show_billed_characters","prepareRephraseSettings","rephraseSelectors","toneorstyle","selList","se","i","match","init","cfg","APP_VERSION","version","debugTemp","callTranslations","keys","translations","rephrases","t","source_lang","prepareTranslation","canimprove","includes","push","on","DEEPL_SUCCESS","DEEPL_FAILED","translate","DEEPL_RF_SUCCESS","DEEPL_RF_FAILED","saveTranslations","items","map","userPrefs","TR_DB_SUCCESS","TR_DB_FAILED","updateTranslationsInDb","initTempForKey","editorSettings","sourceTextEncoded","multilangRawTextEncoded","sourceText","fromBase64","tokenised","preprocess","editorType","tokenizedText","statuses","wait","expressions","initTemp","moodleTargetToSave","ON_ITEM_TRANSLATED","ON_DB_FAILED","ON_ITEM_SAVED","ON_ITEM_NOT_SAVED","ON_TRANSLATION_FAILED","ON_REPHRASE_FAILED","ON_DB_SAVE_SUCCESS","isTranslatable","translated"],"mappings":"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"}