{"version":3,"file":"translation.min.js","sources":["../../src/local/translation.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n\n/**\n * @module     local_deepler/deepler\n * @file       amd/src/local/translation.js\n * @copyright  2025 Bruno Baudry <bruno.baudry@bfh.ch>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\ndefine([\n    './api', './utils', './selectors', './ui', './tokeniser', './customevents'],\n    (Api, Utils, Selectors, Ui, Tokeniser, Events) => {\n    let tempTranslations = {};\n    let escapePatterns = {};\n    let mainSourceLang = \"\";\n    let targetLang = \"\";\n    let settings = {};\n    const setMainLangs = (source, target) => {\n        mainSourceLang = source;\n        targetLang = target;\n    };\n    const saveTranslations = (keys, maineditorIsTextArea) => {\n        const data = keys.map(item => prepareDbUpdateItem(item, maineditorIsTextArea));\n        Events.on(Api.TR_DB_SUCCESS);\n        Api.updateTranslationsInDb(data);\n        // Api.callApi(\"local_deepler_update_translation\", {data: data}).done(handleAjaxUpdateDBResponse);\n    };\n        const prepareDbUpdateItem = (item, maineditorIsTextArea) => {\n            const key = item.key;\n            const textTosave = getupdatedtext(key, maineditorIsTextArea);\n            item.text = textTosave;\n            return {\n                courseid: item.courseid,\n                id: item.id,\n                tid: item.tid,\n                field: item.field,\n                table: item.table,\n                text: textTosave\n            };\n        };\n        /**\n         * Update Textarea.\n         *\n         * @param {string} key\n         * @param {boolean} maineditorIsTextArea\n         * @returns {string}\n         * translation.js\n         */\n        const getupdatedtext = (key, maineditorIsTextArea) => {\n            const sourceItemLang = tempTranslations[key].sourceLang;\n            const fieldText = tempTranslations[key].fieldText; // Translation\n            const translation = getEditorText(tempTranslations[key].editor, maineditorIsTextArea);// Translation\n            const source = getSourceText(key);// Translation\n            const isFirstTranslation = fieldText.indexOf(\"{mlang\") === -1;\n            const isSourceOther = sourceItemLang === mainSourceLang;\n            const tagPatterns = {\n                \"other\": \"({mlang other)(.*?){mlang}\",\n                \"target\": `({mlang ${targetLang}}(.*?){mlang})`,\n                \"source\": `({mlang ${sourceItemLang}}(.*?){mlang})`\n            };\n            const langsItems = {\n                \"fullContent\": fieldText,\n                \"other\": `{mlang other}${source}{mlang}`,\n                \"target\": `{mlang ${targetLang}}${translation}{mlang}`,\n                \"source\": `{mlang ${sourceItemLang}}${source}{mlang}`\n            };\n            if (isFirstTranslation) {\n                // No mlang tag : easy.\n                if (isSourceOther) {\n                    return langsItems.other + langsItems.target;\n                } else {\n                    return langsItems.other + langsItems.source + langsItems.target;\n                }\n            }\n            // Alreaddy mlang tag-s.\n            return additionalUpdate(isSourceOther, tagPatterns, langsItems);\n        };\n        /**\n         * Update Textarea when there was mlang tags.\n         * Main regex '({mlang ([a-z]{2,5})}(.*?){mlang})'.\n         * @param {boolean} isSourceOther\n         * @param {string} tagPatterns\n         * @param {string} langsItems\n         * @returns {string} {string}\n         * @todo MDL-000 refactor this.\n         */\n        const additionalUpdate = (isSourceOther, tagPatterns, langsItems) => {\n            let manipulatedText = langsItems.fullContent;\n            // Do we have a TARGET tag already ?\n            const targetReg = new RegExp(tagPatterns.target, \"sg\");\n            const hasTagTarget = manipulatedText.match(targetReg);\n            if (hasTagTarget) {\n                // Yes replace it.\n                manipulatedText = manipulatedText.replace(targetReg, Tokeniser.escapeReplacementString(langsItems.target));\n            } else {\n                // No, add it at the end.\n                const lastMlangClosingTagEnd = manipulatedText.lastIndexOf(\"{mlang}\") + \"{mlang}\".length;\n                manipulatedText = [manipulatedText.slice(0, lastMlangClosingTagEnd),\n                    langsItems.target,\n                    manipulatedText.slice(lastMlangClosingTagEnd)\n                ].join('');\n            }\n            // Do we have a OTHER tag already ?\n            const otherReg = new RegExp(tagPatterns.other, \"sg\");\n            const hasTagOther = manipulatedText.match(otherReg);\n            // Do we have a SOURCE tag already ?\n            const sourceReg = new RegExp(tagPatterns.other, \"sg\");\n            const hasTagSource = manipulatedText.match(sourceReg);\n            if (isSourceOther) {\n                // Whatever was the {mlang other} tag language we need to replace it by this source.\n                manipulatedText = manipulatedText.replace(otherReg, Tokeniser.escapeReplacementString(langsItems.other));\n                if (hasTagSource) {\n                    // And remove the {mlang source} tag if found.\n                    manipulatedText.replace(sourceReg, \"\");\n                }\n            } else {\n                if (!hasTagOther) {\n                    // We still add this source as otherTag of the so that it can be replaced further.\n                    const firstMlangClosingTagEnd = manipulatedText.indexOf(\"{mlang\");\n                    manipulatedText = [manipulatedText.slice(0, firstMlangClosingTagEnd),\n                        langsItems.other,\n                        manipulatedText.slice(firstMlangClosingTagEnd)\n                    ].join('');\n                }\n                if (!hasTagSource) {\n                    // Add the {mlang source} tag if not found.\n                    manipulatedText.replace(sourceReg, Tokeniser.escapeReplacementString(langsItems.source));\n                }\n            }\n            return manipulatedText;\n        };\n        /**\n         * Editor's text content.\n         *\n         * @param {HTMLElement} editor\n         * @param {boolean} maineditorIsTextArea\n         * @returns {string}\n         * translation.js\n         */\n        const getEditorText = (editor, maineditorIsTextArea) => {\n            let text = editor.innerHTML;\n            if (maineditorIsTextArea) {\n                text = Utils.decodeHTML(text);\n            }\n            return text;\n        };\n        /**\n         * Source text de-tokenised.\n         *\n         * @param {String} key\n         * @returns {String}\n         * translation.js\n         */\n        const getSourceText = (key) => {\n            const sourceTokenised = tempTranslations[key].source;\n            return Tokeniser.postprocess(sourceTokenised, tempTranslations[key].tokens);\n        };\n    /**\n     * Initializing object storage before translation.\n     * @param {string} key\n     * @param {editor: object, editorType: string} editorSettings\n     * @param {string} sourceTextEncoded\n     * @param {string} multilangRawTextEncoded\n     * @param {string} sourceLang\n     */\n    const initTempForKey = (key, editorSettings, sourceTextEncoded, multilangRawTextEncoded, sourceLang) => {\n        const sourceText = Utils.fromBase64(sourceTextEncoded);\n        const fieldText = Utils.fromBase64(multilangRawTextEncoded);\n        const tokenised = Tokeniser.preprocess(sourceText, escapePatterns, escapePatterns);\n        tempTranslations[key] = {\n            editorType: editorSettings.editorType,\n            editor: editorSettings.editor,\n            source: tokenised.tokenizedText,\n            sourceLang: sourceLang,\n            fieldText: fieldText,\n            status: Selectors.statuses.wait,\n            translation: '',\n            tokens: tokenised.expressions\n        };\n    };\n    /**\n     * Wipe pout the temp.\n     * @param {string} key\n     */\n    const initTemp = (key)=>{\n        tempTranslations[key] = {\n            editorType: null,\n            editor: null,\n            source: '',\n            sourceLang: '',\n            fieldText: '',\n            status: '',\n            translation: '',\n            tokens: []\n        };\n    };\n\n    const prepareTranslation = (key) => {\n        return {\n            text: tempTranslations[key].source,\n            source_lang: tempTranslations[key].sourceLang,\n            key: key\n        };\n    };\n\n    /* Const getTranslation = (key) => {\n        let formData = Utils.prepareFormData(key);\n        Api.translate(formData, (response) => {\n            let tr = Utils.postprocess(response.translations[0].text, tempTranslations[key].tokens);\n            tempTranslations[key].editor.innerHTML = tr;\n            tempTranslations[key].translation = tr;\n            Ui.setIconStatus(key, Selectors.statuses.tosave, true);\n        });\n    };*/\n    /**\n     * Call the external translation service to translate the selected keys.\n     *\n     * @param {array} keys\n     */\n    const callTranslations = (keys) => {\n        const translations = [];\n        const options = prepareAdvancedSettings(document.querySelector(Selectors.actions.targetSwitcher).value);\n        keys.forEach((key) => {\n            // InitTempForKey(key);\n            translations.push(prepareTranslation(key));\n        });\n        Events.on(Api.DEEPL_SUCCESS, onTranslateSuccess);\n        Events.on(Api.DEEPL_FAILED, onTranslateFailed);\n        Api.translate(translations, options);\n    };\nconst onTranslateSuccess = (response)=>{\n    response.translations.forEach((tr) => {\n        // @todo emit event.\n        let key = tr.key;\n        let translation = Utils.postprocess(tr.text, tempTranslations[key].tokens);\n        tempTranslations[key].editor.innerHTML = translation;\n        tempTranslations[key].translation = translation;\n        Ui.setIconStatus(key, Selectors.statuses.tosave, true);\n    });\n};\nconst onTranslateFailed = (status, error)=>{\n    window.console.log(status, error);\n};\n    /**\n     * Compile Advanced settings.\n     *\n     * @param {string} targetLang\n     * @returns {{}}\n     * translation.js ok\n     */\n    const prepareAdvancedSettings = (targetLang) => {\n        Utils.info('prepareAdvancedSettings');\n        escapePatterns.LATEX = document.querySelector(Selectors.actions.escapeLatex).checked;\n        escapePatterns.PRETAG = document.querySelector(Selectors.actions.escapePre).checked;\n        // eslint-disable-next-line camelcase\n        settings.tag_handling = document.querySelector(Selectors.deepl.tagHandling).checked ? 'html' : 'xml';//\n        settings.context = document.querySelector(Selectors.deepl.context).value ?? null;//\n        // eslint-disable-next-line camelcase\n        settings.split_sentences = document.querySelector(Selectors.deepl.splitSentences).value;//\n        // eslint-disable-next-line camelcase\n        settings.preserve_formatting = document.querySelector(Selectors.deepl.preserveFormatting).checked;//\n        settings.formality = document.querySelector('[name=\"local_deepler/formality\"]:checked').value;\n        // eslint-disable-next-line camelcase\n        settings.glossary_id = document.querySelector(Selectors.deepl.glossaryId).value;//\n        // eslint-disable-next-line camelcase\n        settings.outline_detection = document.querySelector(Selectors.deepl.outlineDetection).checked;//\n        // eslint-disable-next-line camelcase\n        settings.non_splitting_tags = Utils.toJsonArray(document.querySelector(Selectors.deepl.nonSplittingTags).value);\n        // eslint-disable-next-line camelcase\n        settings.splitting_tags = Utils.toJsonArray(document.querySelector(Selectors.deepl.splittingTags).value);\n        // eslint-disable-next-line camelcase\n        settings.ignore_tags = Utils.toJsonArray(document.querySelector(Selectors.deepl.ignoreTags).value);\n        // eslint-disable-next-line camelcase\n        settings.target_lang = targetLang.toUpperCase();\n        // eslint-disable-next-line camelcase\n        settings.model_type = document.querySelector(Selectors.deepl.modelType).value ?? 'prefer_quality_optimized';\n        // eslint-disable-next-line camelcase\n        settings.show_billed_characters = true;\n\n        // Settings.auth_key = config.apikey;\n        // return settings;\n    };\n    /**\n     * Check if the item is translatable.\n     *\n     * @param {string} sourceLang\n     */\n    const isTranslatable = (sourceLang = '') =>{\n        Utils.info(targetLang, sourceLang, targetLang === (sourceLang === '' ? mainSourceLang : sourceLang));\n        return targetLang === (sourceLang === '' ? mainSourceLang : sourceLang);\n    };\n        const translated = (key)=>{\n            return tempTranslations[key]?.translation?.length > 0;\n        };\n        return {\n        callTranslations: callTranslations,\n        saveTranslations: saveTranslations,\n        initTempForKey: initTempForKey,\n        initTemp: initTemp,\n        /* TempTranslations: tempTranslations,*/\n        setMainLangs: setMainLangs,\n        isTranslatable: isTranslatable,\n        translated: translated\n    };\n});\n"],"names":["define","Api","Utils","Selectors","Ui","Tokeniser","Events","tempTranslations","escapePatterns","mainSourceLang","targetLang","settings","prepareDbUpdateItem","item","maineditorIsTextArea","key","textTosave","getupdatedtext","text","courseid","id","tid","field","table","sourceItemLang","sourceLang","fieldText","translation","getEditorText","editor","source","getSourceText","isFirstTranslation","indexOf","isSourceOther","tagPatterns","langsItems","other","target","additionalUpdate","manipulatedText","fullContent","targetReg","RegExp","match","replace","escapeReplacementString","lastMlangClosingTagEnd","lastIndexOf","length","slice","join","otherReg","hasTagOther","sourceReg","hasTagSource","firstMlangClosingTagEnd","innerHTML","decodeHTML","sourceTokenised","postprocess","tokens","onTranslateSuccess","response","translations","forEach","tr","setIconStatus","statuses","tosave","onTranslateFailed","status","error","window","console","log","prepareAdvancedSettings","info","LATEX","document","querySelector","actions","escapeLatex","checked","PRETAG","escapePre","tag_handling","deepl","tagHandling","context","value","split_sentences","splitSentences","preserve_formatting","preserveFormatting","formality","glossary_id","glossaryId","outline_detection","outlineDetection","non_splitting_tags","toJsonArray","nonSplittingTags","splitting_tags","splittingTags","ignore_tags","ignoreTags","target_lang","toUpperCase","model_type","modelType","show_billed_characters","callTranslations","keys","options","targetSwitcher","push","source_lang","prepareTranslation","on","DEEPL_SUCCESS","DEEPL_FAILED","translate","saveTranslations","data","map","TR_DB_SUCCESS","updateTranslationsInDb","initTempForKey","editorSettings","sourceTextEncoded","multilangRawTextEncoded","sourceText","fromBase64","tokenised","preprocess","editorType","tokenizedText","wait","expressions","initTemp","setMainLangs","isTranslatable","translated"],"mappings":"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"}