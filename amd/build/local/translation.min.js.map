{"version":3,"file":"translation.min.js","sources":["../../src/local/translation.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n\n/**\n * @module     local_deepler/deepler\n * @file       amd/src/local/translation.js\n * @copyright  2025 Bruno Baudry <bruno.baudry@bfh.ch>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\ndefine([\n    'core/log', './api', './utils', './selectors', './tokeniser', './customevents'],\n    (Log, Api, Utils, Selectors, Tokeniser, Events) => {\n    let tempTranslations = {};\n    let escapePatterns = {};\n    let mainSourceLang = \"\";\n    let targetLang = \"\";\n    let availableSourceLangs = [];\n    let courseid = 0;\n    let userid = 0;\n    let settings = {};\n    const ON_ITEM_TRANSLATED = 'onItemTranslated';\n    // Const ON_ITEM_NOT_TRANSLATED = 'onItemsNotTranslated';\n    const ON_ITEM_SAVED = 'onItemSaved';\n    const ON_ITEM_NOT_SAVED = 'onItemNotSaved';\n    const ON_TRANSLATION_FAILED = 'onTranslationFailed';\n    const ON_DB_SAVE_SUCCESS = 'onDbSuccess';\n    const ON_DB_FAILED = 'onDbFailed';\n    const setMainLangs = (deeplsourcelangs, source = '', target = '') => {\n        availableSourceLangs = deeplsourcelangs.split('|');\n        if (source !== '') {\n            mainSourceLang = source;\n        }\n        if (target !== '') {\n            targetLang = target;\n        }\n    };\n    const onTrDbSuccess = (data)=>{\n        Log.info(`translation/onTrDbSuccess:46`);\n        Log.info(data);\n        if (data.length === 0) {\n            Log.error(data);\n            Events.emit(ON_DB_FAILED, 'no data returned', '');\n            // ShowModal();\n        } else {\n            const errors = data.filter((item) => item.error !== '');\n            data.forEach((item) => {\n                // Ui.setIconStatus(item.key, Selectors.statuses.saved, true);\n                Log.debug(`translation/:54`);\n                Log.debug(item);\n                if (item.error === '') {\n                    Events.emit(ON_ITEM_SAVED, item.keyid, item.text);\n                } else {\n                    Events.emit(ON_ITEM_NOT_SAVED, item.keyid, item.error);\n                }\n            });\n            Events.emit(ON_DB_SAVE_SUCCESS, errors);\n        }\n    };\n    /**\n     * Translation DB failed.\n     * @param {int} status\n     * @param {string} error\n     */\n    const onTrDbFailed = (status, error) =>{\n            Events.emit(ON_DB_FAILED, error, status);\n            Log.trace(status);\n            Log.trace(error);\n        };\n    /**\n     * Save translations to the DB.\n     * @param {array} items\n     * @param {object} config\n     */\n    const saveTranslations = (items, config) => {\n        const data = items.map(item => prepareDbUpdateItem(item, config.userPrefs === 'textarea'));\n        Events.on(Api.TR_DB_SUCCESS, onTrDbSuccess);\n        Events.on(Api.TR_DB_FAILED, onTrDbFailed);\n        Api.updateTranslationsInDb(data, userid, courseid);\n    };\n        /**\n         * Prepare the data to be saved in the DB.\n         * @param {object} item\n         * @param {bool} maineditorIsTextArea\n         * @returns {{ id, tid: *, field, table, text: string}}\n         */\n        const prepareDbUpdateItem = (item, maineditorIsTextArea) => {\n            const key = item.key;\n            const textTosave = getupdatedtext(key, maineditorIsTextArea);\n            item.text = textTosave;\n            return {\n                id: item.id,\n                tid: item.tid,\n                field: item.field,\n                table: item.table,\n                text: textTosave,\n                cmid: item.cmid,\n                keyid: key\n            };\n        };\n        /**\n         * Update Textarea.\n         *\n         * @param {string} key\n         * @param {boolean} maineditorIsTextArea\n         * @returns {string}\n         * translation.js\n         */\n        const getupdatedtext = (key, maineditorIsTextArea) => {\n            const sourceItemLang = prepareSourceItemLang(tempTranslations[key].sourceLang);\n            const compatibleTargetLang = prepareSourceItemLang(targetLang);\n            const fieldText = tempTranslations[key].fieldText; // Translation\n            const translation = getEditorText(tempTranslations[key].editor, maineditorIsTextArea);// Translation\n            const source = getSourceText(key);// Translation\n            const isFirstTranslation = fieldText.indexOf(\"{mlang\") === -1;\n            const isSourceOther = sourceItemLang === mainSourceLang;\n            const tagPatterns = {\n                \"other\": \"({mlang other)(.*?){mlang}\",\n                \"target\": `({mlang ${compatibleTargetLang}}(.*?){mlang})`,\n                \"source\": `({mlang ${sourceItemLang}}(.*?){mlang})`\n            };\n            const langsItems = {\n                \"fullContent\": fieldText,\n                \"other\": `{mlang other}${source}{mlang}`,\n                \"target\": `{mlang ${compatibleTargetLang}}${translation}{mlang}`,\n                \"source\": `{mlang ${sourceItemLang}}${source}{mlang}`\n            };\n            if (isFirstTranslation) {\n                // No mlang tag : easy.\n                if (isSourceOther) {\n                    return langsItems.other + langsItems.target;\n                } else {\n                    return langsItems.other + langsItems.source + langsItems.target;\n                }\n            }\n            // Alreaddy mlang tag-s.\n            return additionalUpdate(isSourceOther, tagPatterns, langsItems);\n        };\n        /**\n         * Util to\n         *\n         * @param {string} l\n         */\n        const prepareSourceItemLang = (l)=>{\n            let lang = l;\n            // If lang not in the sources keep the root lang.\n            if (availableSourceLangs.indexOf(lang) === -1) {\n                lang = l.split('-', 1).join('');\n            }\n            return lang.toLowerCase();\n        };\n        /**\n         * Update Textarea when there was mlang tags.\n         * Main regex '({mlang ([a-z]{2,5})}(.*?){mlang})'.\n         * @param {boolean} isSourceOther\n         * @param {string} tagPatterns\n         * @param {string} langsItems\n         * @returns {string} {string}\n         * @todo MDL-000 refactor this.\n         */\n        const additionalUpdate = (isSourceOther, tagPatterns, langsItems) => {\n            let manipulatedText = langsItems.fullContent;\n            // Do we have a TARGET tag already ?\n            const targetReg = new RegExp(tagPatterns.target, \"sg\");\n            const hasTagTarget = manipulatedText.match(targetReg);\n            if (hasTagTarget) {\n                // Yes replace it.\n                manipulatedText = manipulatedText.replace(targetReg, Tokeniser.escapeReplacementString(langsItems.target));\n            } else {\n                // No, add it at the end.\n                const lastMlangClosingTagEnd = manipulatedText.lastIndexOf(\"{mlang}\") + \"{mlang}\".length;\n                manipulatedText = [manipulatedText.slice(0, lastMlangClosingTagEnd),\n                    langsItems.target,\n                    manipulatedText.slice(lastMlangClosingTagEnd)\n                ].join('');\n            }\n            // Do we have a OTHER tag already ?\n            const otherReg = new RegExp(tagPatterns.other, \"sg\");\n            const hasTagOther = manipulatedText.match(otherReg);\n            // Do we have a SOURCE tag already ?\n            const sourceReg = new RegExp(tagPatterns.other, \"sg\");\n            const hasTagSource = manipulatedText.match(sourceReg);\n            if (isSourceOther) {\n                // Whatever was the {mlang other} tag language we need to replace it by this source.\n                manipulatedText = manipulatedText.replace(otherReg, Tokeniser.escapeReplacementString(langsItems.other));\n                if (hasTagSource) {\n                    // And remove the {mlang source} tag if found.\n                    manipulatedText.replace(sourceReg, \"\");\n                }\n            } else {\n                if (!hasTagOther) {\n                    // We still add this source as otherTag of the so that it can be replaced further.\n                    const firstMlangClosingTagEnd = manipulatedText.indexOf(\"{mlang\");\n                    manipulatedText = [manipulatedText.slice(0, firstMlangClosingTagEnd),\n                        langsItems.other,\n                        manipulatedText.slice(firstMlangClosingTagEnd)\n                    ].join('');\n                }\n                if (!hasTagSource) {\n                    // Add the {mlang source} tag if not found.\n                    manipulatedText.replace(sourceReg, Tokeniser.escapeReplacementString(langsItems.source));\n                }\n            }\n            return manipulatedText;\n        };\n        /**\n         * Editor's text content.\n         *\n         * @param {HTMLElement} editor\n         * @param {boolean} maineditorIsTextArea\n         * @returns {string}\n         * translation.js\n         */\n        const getEditorText = (editor, maineditorIsTextArea) => {\n            let text = editor.innerHTML;\n            if (maineditorIsTextArea) {\n                text = Utils.decodeHTML(text);\n            }\n            return text;\n        };\n        /**\n         * Source text de-tokenised.\n         *\n         * @param {String} key\n         * @returns {String}\n         * translation.js\n         */\n        const getSourceText = (key) => {\n            const sourceTokenised = tempTranslations[key].source;\n            return Tokeniser.postprocess(sourceTokenised, tempTranslations[key].tokens);\n        };\n    /**\n     * Initializing object storage before translation.\n     * @param {string} key\n     * @param {editor: object, editorType: string} editorSettings\n     * @param {string} sourceTextEncoded\n     * @param {string} multilangRawTextEncoded\n     * @param {string} sourceLang\n     */\n    const initTempForKey = (key, editorSettings, sourceTextEncoded, multilangRawTextEncoded, sourceLang) => {\n        const sourceText = Utils.fromBase64(sourceTextEncoded);\n        const fieldText = Utils.fromBase64(multilangRawTextEncoded);\n        const tokenised = Tokeniser.preprocess(sourceText, escapePatterns, escapePatterns);\n        tempTranslations[key] = {\n            editorType: editorSettings.editorType,\n            editor: editorSettings.editor,\n            source: tokenised.tokenizedText,\n            sourceLang: sourceLang,\n            fieldText: fieldText,\n            status: Selectors.statuses.wait,\n            translation: '',\n            tokens: tokenised.expressions\n        };\n    };\n    /**\n     * Wipe pout the temp.\n     * @param {string} key\n     */\n    const initTemp = (key)=>{\n        tempTranslations[key] = {\n            editorType: null,\n            editor: null,\n            source: '',\n            sourceLang: '',\n            fieldText: '',\n            status: '',\n            translation: '',\n            tokens: []\n        };\n    };\n\n    const prepareTranslation = (key) => {\n        return {\n            text: tempTranslations[key].source,\n            // eslint-disable-next-line camelcase\n            source_lang: tempTranslations[key].sourceLang,\n            key: key\n        };\n    };\n    /**\n     * Call the external translation service to translate the selected keys.\n     *\n     * @param {array} keys\n     */\n    const callTranslations = (keys) => {\n        const translations = [];\n        prepareAdvancedSettings(targetLang);\n        keys.forEach((key) => {\n            translations.push(prepareTranslation(key));\n        });\n        Events.on(Api.DEEPL_SUCCESS, onTranslateSuccess);\n        Events.on(Api.DEEPL_FAILED, onTranslateFailed);\n        Api.translate(translations, settings, Api.APP_VERSION);\n    };\nconst onTranslateSuccess = (response)=>{\n    Log.info(`translation//onTranslateSuccess::response`);\n    Log.info(response);\n    response.forEach((tr) => {\n        if (tr.error === '') {\n            let key = tr.key;\n            let translation = Tokeniser.postprocess(tr.translated_text, tempTranslations[key].tokens);\n            Log.debug(`translation/onTranslateSuccess/each::translation Tokeniser.postprocess`);\n            Log.debug(translation);\n            tempTranslations[key].editor.innerHTML = translation;\n            Log.debug(`translation/onTranslateSuccess::tempTranslations[key].editor.innerHTML`);\n            Log.debug(tempTranslations[key].editor.innerHTML);\n            tempTranslations[key].translation = translation;\n            Events.emit(ON_ITEM_TRANSLATED, key);\n        } else {\n            Events.emit(ON_TRANSLATION_FAILED, tr.error);\n        }\n    });\n};\nconst onTranslateFailed = (status, error)=>{\n    Events.emit(ON_TRANSLATION_FAILED, status, error);\n};\n    /**\n     * Compile Advanced settings.\n     *\n     * @param {string} targetLang\n     * @returns {{}}\n     * translation.js ok\n     */\n    const prepareAdvancedSettings = (targetLang) => {\n        escapePatterns.LATEX = document.querySelector(Selectors.actions.escapeLatex).checked;\n        escapePatterns.PRETAG = document.querySelector(Selectors.actions.escapePre).checked;\n        // eslint-disable-next-line camelcase\n        settings.tag_handling = document.querySelector(Selectors.deepl.tagHandling).checked ? 'html' : 'xml';//\n        settings.context = document.querySelector(Selectors.deepl.context).value ?? null;//\n        // eslint-disable-next-line camelcase\n        settings.split_sentences = document.querySelector(Selectors.deepl.splitSentences).value;//\n        // eslint-disable-next-line camelcase\n        settings.preserve_formatting = document.querySelector(Selectors.deepl.preserveFormatting).checked;//\n        settings.formality = document.querySelector('[name=\"local_deepler/formality\"]:checked').value;\n        // eslint-disable-next-line camelcase\n        settings.glossary_id = document.querySelector(Selectors.deepl.glossaryId).value;//\n        if (settings.glossary_id !== '') {\n            Utils.setCookie(Utils.COOKIE_PREFIX + mainSourceLang + targetLang + courseid, settings.glossary_id, 703);\n        }\n        // eslint-disable-next-line camelcase\n        settings.outline_detection = document.querySelector(Selectors.deepl.outlineDetection).checked;//\n        // eslint-disable-next-line camelcase\n        settings.non_splitting_tags = Utils.toJsonArray(document.querySelector(Selectors.deepl.nonSplittingTags).value);\n        // eslint-disable-next-line camelcase\n        settings.splitting_tags = Utils.toJsonArray(document.querySelector(Selectors.deepl.splittingTags).value);\n        // eslint-disable-next-line camelcase\n        settings.ignore_tags = Utils.toJsonArray(document.querySelector(Selectors.deepl.ignoreTags).value);\n        // eslint-disable-next-line camelcase\n        settings.target_lang = targetLang.toUpperCase();\n        // eslint-disable-next-line camelcase\n        settings.model_type = document.querySelector(Selectors.deepl.modelType).value ?? 'prefer_quality_optimized';\n        // eslint-disable-next-line camelcase\n        settings.show_billed_characters = true;\n\n        // Settings.auth_key = config.apikey;\n        // return settings;\n    };\n    /**\n     * Check if the item is translatable.\n     * @todo MDL-0000 implement in v1.4.0 (return based on local source)\n     * @param {string} sourceLang\n     */\n    const isTranslatable = (sourceLang = '') =>{\n         Log.info(targetLang, sourceLang, targetLang === (sourceLang === '' ? mainSourceLang : sourceLang));\n        // Return targetLang !== (sourceLang === '' ? mainSourceLang : sourceLang);\n        return targetLang !== '';\n    };\n        const translated = (key)=>{\n            return tempTranslations[key]?.translation?.length > 0;\n        };\n        const init = (cfg) => {\n            Api.APP_VERSION = cfg.version;\n            courseid = cfg.courseid;\n            userid = cfg.userid;\n            setMainLangs(cfg.deeplsourcelangs, cfg.currentlang, cfg.targetlang);\n        };\n        return {\n            init: init,\n        callTranslations: callTranslations,\n        saveTranslations: saveTranslations,\n        initTempForKey: initTempForKey,\n        initTemp: initTemp,\n        ON_ITEM_TRANSLATED: ON_ITEM_TRANSLATED,\n        ON_DB_FAILED: ON_DB_FAILED,\n        ON_ITEM_SAVED: ON_ITEM_SAVED,\n        ON_ITEM_NOT_SAVED: ON_ITEM_NOT_SAVED,\n        ON_TRANSLATION_FAILED: ON_TRANSLATION_FAILED,\n        ON_TRANSLATION_SUCCESS: ON_DB_SAVE_SUCCESS,\n        /* TempTranslations: tempTranslations,*/\n        setMainLangs: setMainLangs,\n        isTranslatable: isTranslatable,\n        translated: translated\n    };\n});\n"],"names":["define","Log","Api","Utils","Selectors","Tokeniser","Events","tempTranslations","escapePatterns","mainSourceLang","targetLang","availableSourceLangs","courseid","userid","settings","setMainLangs","deeplsourcelangs","source","target","split","onTrDbSuccess","data","info","length","error","emit","errors","filter","item","forEach","debug","keyid","text","onTrDbFailed","status","trace","prepareDbUpdateItem","maineditorIsTextArea","key","textTosave","getupdatedtext","id","tid","field","table","cmid","sourceItemLang","prepareSourceItemLang","sourceLang","compatibleTargetLang","fieldText","translation","getEditorText","editor","getSourceText","isFirstTranslation","indexOf","isSourceOther","tagPatterns","langsItems","other","additionalUpdate","l","lang","join","toLowerCase","manipulatedText","fullContent","targetReg","RegExp","match","replace","escapeReplacementString","lastMlangClosingTagEnd","lastIndexOf","slice","otherReg","hasTagOther","sourceReg","hasTagSource","firstMlangClosingTagEnd","innerHTML","decodeHTML","sourceTokenised","postprocess","tokens","onTranslateSuccess","response","tr","translated_text","onTranslateFailed","prepareAdvancedSettings","LATEX","document","querySelector","actions","escapeLatex","checked","PRETAG","escapePre","tag_handling","deepl","tagHandling","context","value","split_sentences","splitSentences","preserve_formatting","preserveFormatting","formality","glossary_id","glossaryId","setCookie","COOKIE_PREFIX","outline_detection","outlineDetection","non_splitting_tags","toJsonArray","nonSplittingTags","splitting_tags","splittingTags","ignore_tags","ignoreTags","target_lang","toUpperCase","model_type","modelType","show_billed_characters","init","cfg","APP_VERSION","version","currentlang","targetlang","callTranslations","keys","translations","push","source_lang","prepareTranslation","on","DEEPL_SUCCESS","DEEPL_FAILED","translate","saveTranslations","items","config","map","userPrefs","TR_DB_SUCCESS","TR_DB_FAILED","updateTranslationsInDb","initTempForKey","editorSettings","sourceTextEncoded","multilangRawTextEncoded","sourceText","fromBase64","tokenised","preprocess","editorType","tokenizedText","statuses","wait","expressions","initTemp","ON_ITEM_TRANSLATED","ON_DB_FAILED","ON_ITEM_SAVED","ON_ITEM_NOT_SAVED","ON_TRANSLATION_FAILED","ON_TRANSLATION_SUCCESS","isTranslatable","translated"],"mappings":"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"}