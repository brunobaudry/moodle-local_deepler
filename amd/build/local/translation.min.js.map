{"version":3,"file":"translation.min.js","sources":["../../src/local/translation.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n\n/**\n * @module     local_deepler/deepler\n * @file       amd/src/local/translation.js\n * @copyright  2025 Bruno Baudry <bruno.baudry@bfh.ch>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\ndefine([\n    'core/log', './api', './utils', './selectors', './tokeniser', './customevents'],\n    (Log, Api, Utils, Selectors, Tokeniser, Events) => {\n        let tempTranslations = {};\n        let escapePatterns = {};\n        let mainSourceLang = \"\";\n        let deeplSourceLang = \"\";\n        let targetLang = \"\";\n        let moodleTargetToSave = \"\";\n        let courseid = 0;\n        let userid = 0;\n        let rephrasesymbol = '';\n        const deeplSettinRegex = /\\[(name=\"local_deepler|data-id=\"local_deepler)\\/(\\w+)\"\\]/i;\n        const ON_ITEM_TRANSLATED = 'onItemTranslated';\n        // Const ON_ITEM_NOT_TRANSLATED = 'onItemsNotTranslated';\n        const ON_ITEM_SAVED = 'onItemSaved';\n        const ON_ITEM_NOT_SAVED = 'onItemNotSaved';\n        const ON_TRANSLATION_FAILED = 'onTranslationFailed';\n        const ON_TRANSLATION_DONE = 'onTranslationDone';\n        const ON_REPHRASE_FAILED = 'onRephraseFailed';\n        const ON_DB_SAVE_SUCCESS = 'onDbSuccess';\n        const ON_DB_FAILED = 'onDbFailed';\n        const trSelectors = [\n            Selectors.deepl.tagHandling,\n            Selectors.deepl.context,\n            Selectors.deepl.splitSentences,\n            Selectors.deepl.preserveFormatting,\n            Selectors.deepl.formality,\n            Selectors.deepl.glossaryId,\n            Selectors.deepl.outlineDetection,\n            Selectors.deepl.nonSplittingTags,\n            Selectors.deepl.splittingTags,\n            Selectors.deepl.ignoreTags,\n            Selectors.deepl.modelType\n        ];\n        /**\n         * Prepare the langaue settings.\n         *\n         * @param {object} config\n         */\n        const setMainLangs = (config) => {\n            if (config.currentlang !== undefined && config.currentlang !== '') {\n                mainSourceLang = config.currentlang;\n            }\n            if (config.targetlang !== undefined && config.targetlang !== '') {\n                targetLang = config.targetlang.toLowerCase();\n            }\n            if (config.deeplsourcelang !== undefined && config.deeplsourcelang !== '') {\n                deeplSourceLang = config.deeplsourcelang.toLowerCase();\n            }\n        };\n        /**\n         * When translation successfully stored in Moodle's DB.\n         *\n         * @param {object} data\n         */\n        const onTrDbSuccess = (data)=>{\n            if (data.length === 0) {\n                Events.emit(ON_DB_FAILED, 'no data returned', '');\n            } else {\n                const errors = data.filter((item) => item.error !== '');\n                data.forEach((item) => {\n                    if (item.error === '') {\n                        // Refreshing the text in the temp obbject in case of new translation without page refresh.\n                        tempTranslations[item.keyid].fieldText = item.text;\n                        Events.emit(ON_ITEM_SAVED, item.keyid, item.text);\n                    } else {\n                        Events.emit(ON_ITEM_NOT_SAVED, item.keyid, item.error);\n                    }\n                });\n                Events.emit(ON_DB_SAVE_SUCCESS, errors);\n            }\n        };\n        /**\n         * Translation DB failed.\n         * @param {int} status\n         * @param {string} error\n         */\n        const onTrDbFailed = (status, error) =>{\n                Events.emit(ON_DB_FAILED, error, status);\n                Log.trace(status);\n                Log.trace(error);\n            };\n        /**\n         * Save translations to the DB.\n         * @param {array} items\n         * @param {bool} userEditorIsTextarea\n         */\n        const saveTranslations = (items, userEditorIsTextarea) => {\n            const data = items.map(item => prepareDbUpdateItem(item, userEditorIsTextarea));\n            Log.debug(`translation/x/saveTranslations::data`);\n            Log.debug(data);\n            Events.on(Api.TR_DB_SUCCESS, onTrDbSuccess);\n            Events.on(Api.TR_DB_FAILED, onTrDbFailed);\n            Api.updateTranslationsInDb(data, userid, courseid);\n        };\n        /**\n         * Prepare the data to be saved in the DB.\n         *\n         * @param {object} item\n         * @param {boolean} maineditorIsTextArea\n         * @returns {{ id, tid: *, field, table, text: string}}\n         */\n        const prepareDbUpdateItem = (item, maineditorIsTextArea) => {\n            const key = item.key;\n            Log.debug(tempTranslations[key]);\n            // Const textTosave = getupdatedtext(key, maineditorIsTextArea);\n            const textTosave = getEditorText(tempTranslations[key].editor, maineditorIsTextArea);\n            Log.debug(`translation/x/prepareDbUpdateItem::textTosave`);\n            Log.debug(textTosave);\n            Log.debug(tempTranslations[key]);\n            Log.debug(mainSourceLang);\n            Log.debug(deeplSourceLang);\n            Log.debug(moodleTargetToSave);\n            // TextTosave = getEditorText(key, maineditorIsTextArea);\n            return {\n                tid: item.tid,\n                text: textTosave,\n                keyid: key,\n                mainsourcecode: mainSourceLang,\n                sourcecode: tempTranslations[key].sourceLang,\n                targetcode: document.querySelector(Selectors.actions.targetCompatibleSwitcher).value,\n                sourcetext: getSourceText(key)\n            };\n        };\n\n        /**\n         * Editor's text content.\n         *\n         * @param {HTMLElement} editor\n         * @param {boolean} maineditorIsTextArea\n         * @returns {string}\n         * translation.js\n         */\n        const getEditorText = (editor, maineditorIsTextArea) => {\n            let text = editor.innerHTML;\n            if (maineditorIsTextArea) {\n                text = Utils.decodeHTML(text);\n            }\n            return text;\n        };\n        /**\n         * Source text de-tokenised.\n         *\n         * @param {String} key\n         * @returns {String}\n         * translation.js\n         */\n        const getSourceText = (key) => {\n            const sourceTokenised = tempTranslations[key].source;\n            return Tokeniser.postprocess(sourceTokenised, tempTranslations[key].tokens);\n        };\n        /**\n         * Initializing object storage before translation.\n         *\n         * @param {string} key\n         * @param {editor: object, editorType: string} editorSettings\n         * @param {string} sourceTextEncoded\n         * @param {string} multilangRawTextEncoded\n         * @param {string} sourceLang\n         */\n        const initTempForKey = (key,\n                                editorSettings,\n                                sourceTextEncoded,\n                                multilangRawTextEncoded,\n                                sourceLang) => {\n            const sourceText = Utils.fromBase64(sourceTextEncoded);\n            const fieldText = Utils.fromBase64(multilangRawTextEncoded);\n            const tokenised = Tokeniser.preprocess(sourceText, escapePatterns);\n            tempTranslations[key] = {\n                editorType: editorSettings.editorType,\n                editor: editorSettings.editor,\n                source: tokenised.tokenizedText,\n                sourceLang: sourceLang,\n                fieldText: fieldText,\n                status: Selectors.process.wait,\n                translation: '',\n                tokens: tokenised.expressions\n            };\n        };\n        const updatTempStatusAll = (status)=>{\n            tempTranslations.map(\n                (item)=>{\n                    item.status = status;\n                }\n            );\n        };\n        const updateTempStatus = (key, status)=>{\n            tempTranslations[key].status = status;\n        };\n        const updateTempTokenized = (key, sourceText)=>{\n            const tokenised = Tokeniser.preprocess(sourceText, escapePatterns);\n            tempTranslations[key].source = tokenised.tokenizedText;\n            tempTranslations[key].tokens = tokenised.expressions;\n\n        };\n        const updateTempSourceLang = (key, lang)=>{\n            tempTranslations[key].sourceLang = lang;\n        };\n        /**\n         * Initialize out the temp.\n         * @param {String} key\n         * @param {HTMLElement} editorNode\n         * @param {String} editorType\n         * @param {String} sourceTextEncoded\n         * @param {String} multilangRawTextEncoded\n         */\n        const initTemp = (key,\n                          editorNode,\n                          editorType,\n                          sourceTextEncoded,\n                          multilangRawTextEncoded)=>{\n            const sourceText = Utils.fromBase64(sourceTextEncoded);\n            const tokenised = Tokeniser.preprocess(sourceText, escapePatterns);\n            tempTranslations[key] = {\n                editorType: editorType,\n                editor: editorNode,\n                source: tokenised.tokenizedText,\n                sourceLang: mainSourceLang,\n                fieldText: Utils.fromBase64(multilangRawTextEncoded),\n                status: Selectors.process.wait,\n                translation: '',\n                tokens: tokenised.expressions\n            };\n        };\n        /**\n         * Prepare the texts for the external api calls.\n         *\n         * @param {string} key\n         * @returns {{text, source_lang: (string|string|*), key}}\n         */\n        const prepareTranslation = (key) => {\n            return {\n                text: tempTranslations[key].source,\n                // eslint-disable-next-line camelcase\n                source_lang: tempTranslations[key].sourceLang,\n                key: key\n            };\n        };\n        /**\n         * Call the external translation service to translate the selected keys.\n         *\n         * @param {array} keys\n         * @param {object} config\n         * @param {object} settings\n         * @return void\n         */\n        const callTranslations = (keys, config, settings) => {\n            rephrasesymbol = config.rephrasesymbol;\n            const translations = [];\n            const rephrases = [];\n            // We parse and check if it is a tranlsation or text improvement.\n            keys.forEach((key) => {\n                const t = prepareTranslation(key);\n                if (!config.isfree && t.source_lang.includes(rephrasesymbol)) {\n                    delete t.source_lang;\n                    Log.debug(`translation/x/callTranslations::t`);\n                    Log.debug(t);\n                    rephrases.push(t);\n                } else {\n                    translations.push(t);\n                }\n            });\n            if (translations.length > 0) {\n                Events.on(Api.DEEPL_SUCCESS, onTranslateSuccess);\n                Events.on(Api.DEEPL_FAILED, onTranslateFailed);\n                 Api.translate(translations, prepareTranslationSettings(settings), Api.APP_VERSION);\n            }\n            if (rephrases.length > 0) {\n                Events.on(Api.DEEPL_RF_SUCCESS, onRephraseSuccess);\n                Events.on(Api.DEEPL_RF_FAILED, onRephaseFailed);\n                Api.rephrase(rephrases, prepareRephraseSettings(settings), Api.APP_VERSION);\n            }\n        };\n        /**\n         * When translation went good.\n         *\n         * @param {object} response\n         */\n        const onTranslateSuccess = (response)=>{\n            Log.info(response);\n            const glossaries = [];\n            response.forEach((tr) => {\n                let key = tr.key;\n                if (tr.error === '') {\n                    // For now used glossary_id should, be the same for the batch,\n                    // but it would make sense to use a single glossary for each text.\n                    if (glossaries.indexOf(tr.glossary_id) === -1 && tr.glossary_id.trim() !== '') {\n                        glossaries.push(tr.glossary_id);\n                    }\n                    let translation = Tokeniser.postprocess(tr.translated_text, tempTranslations[key].tokens);\n                    tempTranslations[key].editor.innerHTML = translation;\n                    tempTranslations[key].translation = translation;\n                    tempTranslations[key].status = Selectors.process.tosave;\n                    Events.emit(ON_ITEM_TRANSLATED, key);\n                } else {\n                    tempTranslations[key].status = Selectors.process.failed;\n                    Events.emit(ON_TRANSLATION_FAILED, tr.error);\n                }\n            });\n            if (glossaries.length > 0) {\n                Api.updateGlossariesUsage(glossaries);\n            }\n            Events.emit(ON_TRANSLATION_DONE);\n        };\n        /**\n         * When rephrasing went good.\n         *\n         * @param {object} response\n         */\n        const onRephraseSuccess = (response)=>{\n            response.forEach((tr) => {\n                if (tr.error === '') {\n                    let key = tr.key;\n                    let rephrase = Tokeniser.postprocess(tr.text, tempTranslations[key].tokens);\n                    tempTranslations[key].editor.innerHTML = rephrase;\n                    tempTranslations[key].translation = rephrase;\n                    tempTranslations[key].status = Selectors.process.tosave;\n                    Events.emit(ON_ITEM_TRANSLATED, key);\n                } else {\n                    Events.emit(ON_REPHRASE_FAILED, tr.error);\n                }\n            });\n            Events.emit(ON_TRANSLATION_DONE);\n        };\n        /**\n         * When translation failed.\n         *\n         * @param {int} status\n         * @param {string} error\n         */\n        const onTranslateFailed = (status, error)=>{\n            Events.emit(ON_TRANSLATION_FAILED, status, error);\n        };\n        /**\n         * Event handler for when the rephrase fails.\n         *\n         * @param {int} status\n         * @param {string} error\n         */\n        const onRephaseFailed = (status, error)=>{\n            Events.emit(ON_REPHRASE_FAILED, status, error);\n        };\n        /**\n         * Set up the Deepl settings needed for translations.\n         *\n         * @param {object} settings\n         * @returns {{}}\n         */\n        const prepareTranslationSettings = (settings)=>{\n            const s = filterSetting(settings, trSelectors);\n            // eslint-disable-next-line camelcase\n            s.target_lang = targetLang.toUpperCase();\n            // eslint-disable-next-line camelcase\n            s.show_billed_characters = true;\n            return s;\n        };\n        /**\n         * Set up the Deepl settings needed for rephrases.\n         * @param {object}  settings\n         * @returns {{}}\n         */\n        const prepareRephraseSettings = (settings)=>{\n            const rephraseSelectors = [Selectors.deepl.toneorstyle];\n            const s = filterSetting(settings, rephraseSelectors);\n            // eslint-disable-next-line camelcase\n            s.target_lang = targetLang.toUpperCase();\n            return s;\n        };\n        /**\n         * Filter the UI settings by Deepl service needed set.\n         * @param {object} settings\n         * @param {array}  selList\n         * @returns {{}}\n         */\n        const filterSetting = (settings, selList) =>{\n            const se = {};\n            for (let i in selList) {\n                const set = selList[i].match(deeplSettinRegex)[2];\n                se[set] = settings[selList[i]];\n            }\n            return se;\n        };\n        /**\n         * Checks if translation is done.\n         *\n         * @param {string} key\n         * @returns {boolean}\n         */\n        const translated = (key)=>{\n            return tempTranslations[key]?.translation?.length > 0;\n        };\n        /**\n         * Wrapper to trace the temp for a field.\n         *\n         * @param {string} key\n         */\n        const debugTemp = (key)=>{\n            Log.debug(`translation/x/debugTemp::key`);\n            Log.debug(key);\n            Log.debug(tempTranslations[key]);\n        };\n\n        /**\n         * IOne to start them all.\n         *\n         * @param {object} cfg\n         */\n        const init = (cfg) => {\n            Api.APP_VERSION = cfg.version;\n            courseid = cfg.courseid;\n            userid = cfg.userid;\n            setMainLangs(cfg);\n        };\n        /**\n         * Api to be used by the other modules.\n         */\n        return {\n            init: init,\n            debugTemp: debugTemp,\n            callTranslations: callTranslations,\n            saveTranslations: saveTranslations,\n            initTempForKey: initTempForKey,\n            initTemp: initTemp,\n            setMainLangs: setMainLangs,\n            translated: translated,\n            updateTempSourceLang: updateTempSourceLang,\n            updateTempStatus: updateTempStatus,\n            updatTempStatusAll: updatTempStatusAll,\n            updateTempTokenized: updateTempTokenized,\n            ON_ITEM_TRANSLATED: ON_ITEM_TRANSLATED,\n            ON_DB_FAILED: ON_DB_FAILED,\n            ON_ITEM_SAVED: ON_ITEM_SAVED,\n            ON_ITEM_NOT_SAVED: ON_ITEM_NOT_SAVED,\n            ON_TRANSLATION_FAILED: ON_TRANSLATION_FAILED,\n            ON_TRANSLATION_DONE: ON_TRANSLATION_DONE,\n            ON_REPHRASE_FAILED: ON_REPHRASE_FAILED,\n            ON_DB_SAVE_SUCCESS: ON_DB_SAVE_SUCCESS,\n    };\n});\n"],"names":["define","Log","Api","Utils","Selectors","Tokeniser","Events","tempTranslations","escapePatterns","mainSourceLang","deeplSourceLang","targetLang","courseid","userid","rephrasesymbol","deeplSettinRegex","trSelectors","deepl","tagHandling","context","splitSentences","preserveFormatting","formality","glossaryId","outlineDetection","nonSplittingTags","splittingTags","ignoreTags","modelType","setMainLangs","config","undefined","currentlang","targetlang","toLowerCase","deeplsourcelang","onTrDbSuccess","data","length","emit","errors","filter","item","error","forEach","keyid","fieldText","text","onTrDbFailed","status","trace","prepareDbUpdateItem","maineditorIsTextArea","key","debug","textTosave","getEditorText","editor","tid","mainsourcecode","sourcecode","sourceLang","targetcode","document","querySelector","actions","targetCompatibleSwitcher","value","sourcetext","getSourceText","innerHTML","decodeHTML","sourceTokenised","source","postprocess","tokens","onTranslateSuccess","response","info","glossaries","tr","indexOf","glossary_id","trim","push","translation","translated_text","process","tosave","failed","updateGlossariesUsage","onRephraseSuccess","rephrase","onTranslateFailed","onRephaseFailed","prepareTranslationSettings","settings","s","filterSetting","target_lang","toUpperCase","show_billed_characters","prepareRephraseSettings","rephraseSelectors","toneorstyle","selList","se","i","match","init","cfg","APP_VERSION","version","debugTemp","callTranslations","keys","translations","rephrases","t","source_lang","prepareTranslation","isfree","includes","on","DEEPL_SUCCESS","DEEPL_FAILED","translate","DEEPL_RF_SUCCESS","DEEPL_RF_FAILED","saveTranslations","items","userEditorIsTextarea","map","TR_DB_SUCCESS","TR_DB_FAILED","updateTranslationsInDb","initTempForKey","editorSettings","sourceTextEncoded","multilangRawTextEncoded","sourceText","fromBase64","tokenised","preprocess","editorType","tokenizedText","wait","expressions","initTemp","editorNode","translated","updateTempSourceLang","lang","updateTempStatus","updatTempStatusAll","updateTempTokenized","ON_ITEM_TRANSLATED","ON_DB_FAILED","ON_ITEM_SAVED","ON_ITEM_NOT_SAVED","ON_TRANSLATION_FAILED","ON_TRANSLATION_DONE","ON_REPHRASE_FAILED","ON_DB_SAVE_SUCCESS"],"mappings":";;;;;;AAsBAA,yCAAO,CACH,WAAY,QAAS,UAAW,cAAe,cAAe,mBAC9D,CAACC,IAAKC,IAAKC,MAAOC,UAAWC,UAAWC,cAChCC,iBAAmB,GACnBC,eAAiB,GACjBC,eAAiB,GACjBC,gBAAkB,GAClBC,WAAa,GAEbC,SAAW,EACXC,OAAS,EACTC,eAAiB,SACfC,iBAAmB,4DAUnBC,YAAc,CAChBZ,UAAUa,MAAMC,YAChBd,UAAUa,MAAME,QAChBf,UAAUa,MAAMG,eAChBhB,UAAUa,MAAMI,mBAChBjB,UAAUa,MAAMK,UAChBlB,UAAUa,MAAMM,WAChBnB,UAAUa,MAAMO,iBAChBpB,UAAUa,MAAMQ,iBAChBrB,UAAUa,MAAMS,cAChBtB,UAAUa,MAAMU,WAChBvB,UAAUa,MAAMW,WAOdC,aAAgBC,cACSC,IAAvBD,OAAOE,aAAoD,KAAvBF,OAAOE,cAC3CvB,eAAiBqB,OAAOE,kBAEFD,IAAtBD,OAAOG,YAAkD,KAAtBH,OAAOG,aAC1CtB,WAAamB,OAAOG,WAAWC,oBAEJH,IAA3BD,OAAOK,iBAA4D,KAA3BL,OAAOK,kBAC/CzB,gBAAkBoB,OAAOK,gBAAgBD,gBAQ3CE,cAAiBC,UACC,IAAhBA,KAAKC,OACLhC,OAAOiC,KArCM,aAqCa,mBAAoB,QAC3C,OACGC,OAASH,KAAKI,QAAQC,MAAwB,KAAfA,KAAKC,QAC1CN,KAAKO,SAASF,OACS,KAAfA,KAAKC,OAELpC,iBAAiBmC,KAAKG,OAAOC,UAAYJ,KAAKK,KAC9CzC,OAAOiC,KAlDD,cAkDqBG,KAAKG,MAAOH,KAAKK,OAE5CzC,OAAOiC,KAnDG,iBAmDqBG,KAAKG,MAAOH,KAAKC,UAGxDrC,OAAOiC,KAlDY,cAkDaC,UAQlCQ,aAAe,CAACC,OAAQN,SACtBrC,OAAOiC,KA1DM,aA0DaI,MAAOM,QACjChD,IAAIiD,MAAMD,QACVhD,IAAIiD,MAAMP,QAsBZQ,oBAAsB,CAACT,KAAMU,8BACzBC,IAAMX,KAAKW,IACjBpD,IAAIqD,MAAM/C,iBAAiB8C,YAErBE,WAAaC,cAAcjD,iBAAiB8C,KAAKI,OAAQL,6BAC/DnD,IAAIqD,uDACJrD,IAAIqD,MAAMC,YACVtD,IAAIqD,MAAM/C,iBAAiB8C,MAC3BpD,IAAIqD,MAAM7C,gBACVR,IAAIqD,MAAM5C,iBACVT,IAAIqD,MAzGiB,IA2Gd,CACHI,IAAKhB,KAAKgB,IACVX,KAAMQ,WACNV,MAAOQ,IACPM,eAAgBlD,eAChBmD,WAAYrD,iBAAiB8C,KAAKQ,WAClCC,WAAYC,SAASC,cAAc5D,UAAU6D,QAAQC,0BAA0BC,MAC/EC,WAAYC,cAAchB,OAY5BG,cAAgB,CAACC,OAAQL,4BACvBL,KAAOU,OAAOa,iBACdlB,uBACAL,KAAO5C,MAAMoE,WAAWxB,OAErBA,MASLsB,cAAiBhB,YACbmB,gBAAkBjE,iBAAiB8C,KAAKoB,cACvCpE,UAAUqE,YAAYF,gBAAiBjE,iBAAiB8C,KAAKsB,SAiIlEC,mBAAsBC,WACxB5E,IAAI6E,KAAKD,gBACHE,WAAa,GACnBF,SAASjC,SAASoC,SACV3B,IAAM2B,GAAG3B,OACI,KAAb2B,GAAGrC,MAAc,EAG2B,IAAxCoC,WAAWE,QAAQD,GAAGE,cAAiD,KAA1BF,GAAGE,YAAYC,QAC5DJ,WAAWK,KAAKJ,GAAGE,iBAEnBG,YAAchF,UAAUqE,YAAYM,GAAGM,gBAAiB/E,iBAAiB8C,KAAKsB,QAClFpE,iBAAiB8C,KAAKI,OAAOa,UAAYe,YACzC9E,iBAAiB8C,KAAKgC,YAAcA,YACpC9E,iBAAiB8C,KAAKJ,OAAS7C,UAAUmF,QAAQC,OACjDlF,OAAOiC,KAzRQ,mBAyRiBc,UAEhC9C,iBAAiB8C,KAAKJ,OAAS7C,UAAUmF,QAAQE,OACjDnF,OAAOiC,KAxRW,sBAwRiByC,GAAGrC,UAG1CoC,WAAWzC,OAAS,GACpBpC,IAAIwF,sBAAsBX,YAE9BzE,OAAOiC,KA7RiB,sBAoStBoD,kBAAqBd,WACvBA,SAASjC,SAASoC,QACG,KAAbA,GAAGrC,MAAc,KACbU,IAAM2B,GAAG3B,IACTuC,SAAWvF,UAAUqE,YAAYM,GAAGjC,KAAMxC,iBAAiB8C,KAAKsB,QACpEpE,iBAAiB8C,KAAKI,OAAOa,UAAYsB,SACzCrF,iBAAiB8C,KAAKgC,YAAcO,SACpCrF,iBAAiB8C,KAAKJ,OAAS7C,UAAUmF,QAAQC,OACjDlF,OAAOiC,KAjTQ,mBAiTiBc,UAEhC/C,OAAOiC,KA7SQ,mBA6SiByC,GAAGrC,UAG3CrC,OAAOiC,KAjTiB,sBAyTtBsD,kBAAoB,CAAC5C,OAAQN,SAC/BrC,OAAOiC,KA3TmB,sBA2TSU,OAAQN,QAQzCmD,gBAAkB,CAAC7C,OAAQN,SAC7BrC,OAAOiC,KAlUgB,mBAkUSU,OAAQN,QAQtCoD,2BAA8BC,iBAC1BC,EAAIC,cAAcF,SAAUhF,oBAElCiF,EAAEE,YAAcxF,WAAWyF,cAE3BH,EAAEI,wBAAyB,EACpBJ,GAOLK,wBAA2BN,iBACvBO,kBAAoB,CAACnG,UAAUa,MAAMuF,aACrCP,EAAIC,cAAcF,SAAUO,0BAElCN,EAAEE,YAAcxF,WAAWyF,cACpBH,GAQLC,cAAgB,CAACF,SAAUS,iBACvBC,GAAK,OACN,IAAIC,KAAKF,QAAS,CAEnBC,GADYD,QAAQE,GAAGC,MAAM7F,kBAAkB,IACrCiF,SAASS,QAAQE,WAExBD,UAoCJ,CACHG,KAVUC,MACV5G,IAAI6G,YAAcD,IAAIE,QACtBpG,SAAWkG,IAAIlG,SACfC,OAASiG,IAAIjG,OACbgB,aAAaiF,MAObG,UAtBe5D,MACfpD,IAAIqD,sCACJrD,IAAIqD,MAAMD,KACVpD,IAAIqD,MAAM/C,iBAAiB8C,OAoB3B6D,iBA7KqB,CAACC,KAAMrF,OAAQkE,YACpClF,eAAiBgB,OAAOhB,qBAClBsG,aAAe,GACfC,UAAY,GAElBF,KAAKvE,SAASS,YACJiE,EAtBcjE,CAAAA,MACjB,CACHN,KAAMxC,iBAAiB8C,KAAKoB,OAE5B8C,YAAahH,iBAAiB8C,KAAKQ,WACnCR,IAAKA,MAiBKmE,CAAmBnE,MACxBvB,OAAO2F,QAAUH,EAAEC,YAAYG,SAAS5G,wBAClCwG,EAAEC,YACTtH,IAAIqD,2CACJrD,IAAIqD,MAAMgE,GACVD,UAAUjC,KAAKkC,IAEfF,aAAahC,KAAKkC,MAGtBF,aAAa9E,OAAS,IACtBhC,OAAOqH,GAAGzH,IAAI0H,cAAehD,oBAC7BtE,OAAOqH,GAAGzH,IAAI2H,aAAchC,mBAC3B3F,IAAI4H,UAAUV,aAAcrB,2BAA2BC,UAAW9F,IAAI6G,cAEvEM,UAAU/E,OAAS,IACnBhC,OAAOqH,GAAGzH,IAAI6H,iBAAkBpC,mBAChCrF,OAAOqH,GAAGzH,IAAI8H,gBAAiBlC,iBAC/B5F,IAAI0F,SAASyB,UAAWf,wBAAwBN,UAAW9F,IAAI6G,eAsJnEkB,iBA7UqB,CAACC,MAAOC,8BACvB9F,KAAO6F,MAAME,KAAI1F,MAAQS,oBAAoBT,KAAMyF,wBACzDlI,IAAIqD,8CACJrD,IAAIqD,MAAMjB,MACV/B,OAAOqH,GAAGzH,IAAImI,cAAejG,eAC7B9B,OAAOqH,GAAGzH,IAAIoI,aAActF,cAC5B9C,IAAIqI,uBAAuBlG,KAAMxB,OAAQD,WAwUzC4H,eArQmB,CAACnF,IACAoF,eACAC,kBACAC,wBACA9E,oBACd+E,WAAazI,MAAM0I,WAAWH,mBAC9B5F,UAAY3C,MAAM0I,WAAWF,yBAC7BG,UAAYzI,UAAU0I,WAAWH,WAAYpI,gBACnDD,iBAAiB8C,KAAO,CACpB2F,WAAYP,eAAeO,WAC3BvF,OAAQgF,eAAehF,OACvBgB,OAAQqE,UAAUG,cAClBpF,WAAYA,WACZf,UAAWA,UACXG,OAAQ7C,UAAUmF,QAAQ2D,KAC1B7D,YAAa,GACbV,OAAQmE,UAAUK,cAsPtBC,SAxNa,CAAC/F,IACAgG,WACAL,WACAN,kBACAC,iCACRC,WAAazI,MAAM0I,WAAWH,mBAC9BI,UAAYzI,UAAU0I,WAAWH,WAAYpI,gBACnDD,iBAAiB8C,KAAO,CACpB2F,WAAYA,WACZvF,OAAQ4F,WACR5E,OAAQqE,UAAUG,cAClBpF,WAAYpD,eACZqC,UAAW3C,MAAM0I,WAAWF,yBAC5B1F,OAAQ7C,UAAUmF,QAAQ2D,KAC1B7D,YAAa,GACbV,OAAQmE,UAAUK,cA0MtBtH,aAAcA,aACdyH,WApCgBjG,4FACT9C,iBAAiB8C,4FAAMgC,4EAAa/C,QAAS,GAoCpDiH,qBAtOyB,CAAClG,IAAKmG,QAC/BjJ,iBAAiB8C,KAAKQ,WAAa2F,MAsOnCC,iBAhPqB,CAACpG,IAAKJ,UAC3B1C,iBAAiB8C,KAAKJ,OAASA,QAgP/ByG,mBAxPwBzG,SACxB1C,iBAAiB6H,KACZ1F,OACGA,KAAKO,OAASA,WAsPtB0G,oBA/OwB,CAACtG,IAAKuF,oBACxBE,UAAYzI,UAAU0I,WAAWH,WAAYpI,gBACnDD,iBAAiB8C,KAAKoB,OAASqE,UAAUG,cACzC1I,iBAAiB8C,KAAKsB,OAASmE,UAAUK,aA6OzCS,mBAjauB,mBAkavBC,aA1ZiB,aA2ZjBC,cAjakB,cAkalBC,kBAjasB,iBAkatBC,sBAja0B,sBAka1BC,oBAjawB,oBAkaxBC,mBAjauB,mBAkavBC,mBAjauB"}