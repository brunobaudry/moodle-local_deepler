{"version":3,"file":"utils.min.js","sources":["../../src/local/utils.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * @module     local_deepler/deepler\n * @file       amd/src/local/utils.js\n * @copyright  2025 Bruno Baudry <bruno.baudry@bfh.ch>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\ndefine([], () => {\n    const COOKIE_PREFIX = 'moodle_deepler_glossary_';\n    const MAX_INPUT_LENGTH = 256;\n    /**\n     * Simple helper to manage selectors\n     * @param {string} s\n     * @param {string} k\n     * @returns {*}\n     */\n    const replaceKey = (s, k) => {\n        return s.replace(\"<KEY>\", k);\n    };\n    /**\n     * Transforms a keyid to a key.\n     *\n     * @param {string} k\n     * @returns {string|null}\n     */\n    const keyidToKey = (k) => {\n        if (typeof k !== 'string' || k.length > MAX_INPUT_LENGTH) {\n            return null;\n        }\n        let m = k.match(/^([^-]+)-([^-]+)-([^-]+)-([^-]+)$/i);\n        if (!m) {\n            return null;\n        }\n        return `${m[1]}[${m[2]}][${m[3]}][${m[4]}]`;\n    };\n\n    /**\n     * Json helper\n     * @param {string} s\n     * @param {string} sep\n     * @returns {string}\n     * utils.js\n     */\n    const toJsonArray = (s, sep = \",\") => {\n        return JSON.stringify(s.split(sep));\n    };\n    /**\n     * Helper function to decode the PHP base64 encoded source.\n     * @param {string} encoded\n     * @returns {string}\n     */\n    const fromBase64 = (encoded) => {\n        const binString = atob(encoded); // Maybe we should import js-base64 instead.\n        const bytes = Uint8Array.from(binString, (m) => m.codePointAt(0));\n        return new TextDecoder().decode(bytes);\n    };\n    /**\n     * Helper function for the decode html escaped content.\n     * @param {string} encodedStr\n     * @returns {string}\n     */\n    const decodeHTML = (encodedStr) => {\n        const parser = new DOMParser();\n        const doc = parser.parseFromString(encodedStr, 'text/html');\n        return doc.documentElement.textContent;\n    };\n    /**\n     * Helper to remove HTML from strings.\n     *\n     * @param {string} str\n     * @returns {string|string}\n     * utils.js\n     */\n    const stripHTMLTags = (str) => {\n        let doc = new DOMParser().parseFromString(str, 'text/html');\n        return doc.body.textContent || \"\";\n    };\n    /**\n     * Cookie setter.\n     *\n     * @param {string} name\n     * @param {object} value\n     * @param {int} hours\n     */\n    const setCookie = (name, value, hours)=>{\n        var expires = \"\";\n        if (hours) {\n            var date = new Date();\n            date.setTime(date.getTime() + (hours * 60 * 60 * 1000));\n            expires = \"; expires=\" + date.toUTCString();\n        }\n        document.cookie = name + \"=\" + (value || \"\") + expires + \"; path=/\";\n    };\n    /**\n     * Cookie Getter.\n     *\n     * @param {string} name\n     * @returns {object}\n     */\n   const getCookie = (name) => {\n        const nameEQ = name + \"=\";\n        const ca = document.cookie.split(';');\n        for (let i = 0; i < ca.length; i++) {\n            let c = ca[i];\n            while (c.charAt(0) == ' ') {\n                c = c.substring(1, c.length);\n            }\n            if (c.indexOf(nameEQ) == 0) {\n                return c.substring(nameEQ.length, c.length);\n            }\n        }\n        return null;\n    };\n    /**\n     * Api to be used by the other modules.\n     */\n    return {\n        COOKIE_PREFIX: COOKIE_PREFIX,\n        getCookie: getCookie,\n        setCookie: setCookie,\n        replaceKey: replaceKey,\n        keyidToKey: keyidToKey,\n        decodeHTML: decodeHTML,\n        stripHTMLTags: stripHTMLTags,\n        fromBase64: fromBase64,\n        toJsonArray: toJsonArray\n    };\n});\n"],"names":["define","COOKIE_PREFIX","getCookie","name","nameEQ","ca","document","cookie","split","i","length","c","charAt","substring","indexOf","setCookie","value","hours","expires","date","Date","setTime","getTime","toUTCString","replaceKey","s","k","replace","keyidToKey","m","match","decodeHTML","encodedStr","DOMParser","parseFromString","documentElement","textContent","stripHTMLTags","str","body","fromBase64","encoded","binString","atob","bytes","Uint8Array","from","codePointAt","TextDecoder","decode","toJsonArray","sep","JSON","stringify"],"mappings":";;;;;;AAqBAA,mCAAO,IAAI,KA6GA,CACHC,cA7GkB,2BA8GlBC,UAnBcC,aACRC,OAASD,KAAO,IAChBE,GAAKC,SAASC,OAAOC,MAAM,SAC5B,IAAIC,EAAI,EAAGA,EAAIJ,GAAGK,OAAQD,IAAK,KAC5BE,EAAIN,GAAGI,QACW,KAAfE,EAAEC,OAAO,IACZD,EAAIA,EAAEE,UAAU,EAAGF,EAAED,WAEA,GAArBC,EAAEG,QAAQV,eACHO,EAAEE,UAAUT,OAAOM,OAAQC,EAAED,eAGrC,MAQPK,UAnCc,CAACZ,KAAMa,MAAOC,aACxBC,QAAU,MACVD,MAAO,KACHE,KAAO,IAAIC,KACfD,KAAKE,QAAQF,KAAKG,UAAqB,GAARL,MAAa,GAAK,KACjDC,QAAU,aAAeC,KAAKI,cAElCjB,SAASC,OAASJ,KAAO,KAAOa,OAAS,IAAME,QAAU,YA6BzDM,WAxGe,CAACC,EAAGC,IACZD,EAAEE,QAAQ,QAASD,GAwG1BE,WAhGgBF,OACC,iBAANA,GAAkBA,EAAEhB,OAjBV,WAkBV,SAEPmB,EAAIH,EAAEI,MAAM,6CACXD,YAGKA,EAAE,eAAMA,EAAE,gBAAOA,EAAE,gBAAOA,EAAE,QAF3B,MA2FXE,WA7DgBC,aACD,IAAIC,WACAC,gBAAgBF,WAAY,aACpCG,gBAAgBC,YA2D3BC,cAlDmBC,MACT,IAAIL,WAAYC,gBAAgBI,IAAK,aACpCC,KAAKH,aAAe,GAiD/BI,WAzEgBC,gBACVC,UAAYC,KAAKF,SACjBG,MAAQC,WAAWC,KAAKJ,WAAYb,GAAMA,EAAEkB,YAAY,YACvD,IAAIC,aAAcC,OAAOL,QAuEhCM,YAlFgB,SAACzB,OAAG0B,2DAAM,WACnBC,KAAKC,UAAU5B,EAAEjB,MAAM2C"}