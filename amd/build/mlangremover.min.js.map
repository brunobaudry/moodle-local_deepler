{"version":3,"file":"mlangremover.min.js","sources":["../src/mlangremover.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/*\n * @module     local_mlangremover/mlangremover\n * @copyright  2024 Bruno Baudry <bruno.baudry@bfh.ch>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n// Import libs\nimport Selectors from \"./selectors\";\nimport ajax from \"core/ajax\";\n\n// Initialize the temporary translations dictionary @todo make external class\nlet tempTranslations = {};\nlet config = {};\nlet letsdobutton = {};\nlet checkboxes = [];\n// Let mlangContainer = {};\nlet selectedLanguages = [];\nlet allMLangs = [];\nlet removalMethod = '';\nlet removetag = {};\nlet log = (...a) => {\n    return a;\n};\nlet warn = (...a) => {\n    return a;\n};\nlet info = (...a) => {\n    return a;\n};\nlet error = (...a) => {\n    return a;\n};\nconst debug = {\n    NONE: 0,\n    MINIMAL: 5,\n    NORMAL: 15,\n    ALL: 30719,\n    DEVELOPER: 32767\n};\nconst registerEventListeners = () => {\n    document.addEventListener('change', e => {\n        if (e.target.closest(Selectors.actions.removeRadios)) {\n            grabSetting();\n        }\n        if (e.target.matches('input[type=\"checkbox\"]') && e.target.matches(Selectors.statuses.allMLangCkboxesNames)) {\n            grabSetting();\n        }\n    });\n    document.addEventListener('click', e => {\n        if (e.target.closest(Selectors.actions.letsdobutton)) {\n            doTagRemoval();\n        }\n        if (e.target.closest(Selectors.actions.selectAllBtn)) {\n            toggleAllCheckboxes(e);\n        }\n    });\n};\nconst registerUI = () => {\n    try {\n        removetag = document.querySelector(Selectors.statuses.removetag);\n        document.querySelector(Selectors.actions.selectAllBtn).checked = false;\n        allMLangs = Array.from(document.querySelectorAll(Selectors.statuses.allMLangCkboxes));\n        log(allMLangs, allMLangs.length);\n        // MlangContainer = document.querySelector(Selectors.statuses.selectedMlangsContainer);\n        letsdobutton = document.querySelector(Selectors.actions.letsdobutton);\n        checkboxes = document.querySelectorAll(Selectors.actions.checkBoxes);\n        // Initialise status object.\n        checkboxes.forEach((node) => {\n            tempTranslations[node.dataset.key] = {};\n        });\n    } catch (e) {\n        if (config.debug) {\n            error(e.message);\n        }\n    }\n};\n/**\n * Translation Editor UI.\n * @param {Object} cfg JS Config\n */\nexport const init = (cfg) => {\n    log('init');\n    config = cfg;\n    // Preparing the debugger.\n    if (config.debug === debug.MINIMAL) {\n        error = window.console.error.bind(window.console);\n    } else if (config.debug === debug.NORMAL) {\n        error = window.console.error.bind(window.console);\n        warn = window.console.warn.bind(window.console);\n    } else if (config.debug === debug.ALL) {\n        error = window.console.error.bind(window.console);\n        warn = window.console.warn.bind(window.console);\n        info = window.console.info.bind(window.console);\n    } else if (config.debug === debug.DEVELOPER) {\n        error = window.console.error.bind(window.console);\n        warn = window.console.warn.bind(window.console);\n        info = window.console.info.bind(window.console);\n        log = window.console.log.bind(window.console);\n    }\n    info(\"MLANGREMOVER loaded\");\n    log(config);\n    warn('WARNING MESSAGE ' + config.debug);\n    error(\"testing developper level \" + +config.debug);\n\n    // Setup.\n    registerUI();\n    registerEventListeners();\n    toggleAutotranslateButton();\n    allMLangs.forEach((ck) => {\n        ck.checked = false;\n    });\n    /**\n     * Selection Checkboxes\n     */\n    checkboxes.forEach((e) => {\n        e.addEventListener(\"click\", () => {\n            toggleAutotranslateButton();\n        });\n    });\n};\n\n/**\n * Save Translation to Moodle\n * @param  {String} key Data Key\n */\nconst saveToDB = (key) => {\n    warn('WTF ?!?');\n    // Return;\n    const regex = /(\\w+)\\[(\\d+)\\]\\[(\\w+)\\]\\[(\\d+)\\]/;\n    const matches = key.match(regex);\n    if (!matches) {\n        throw `key ${key} did not match `;\n    }\n    let id = matches[2];\n    let table = matches[1];\n    let field = matches[3];\n    let cmid = matches[4];\n    // Get processing vars.\n    // Restore the source.\n    let updatedtext = tempTranslations[key].new;\n\n    // Get the latest field data\n    let fielddata = {};\n    fielddata.courseid = config.courseid;\n    fielddata.id = parseInt(id);\n    fielddata.table = table;\n    fielddata.field = field;\n    fielddata.cmid = cmid;\n    info(fielddata);\n    // Warn(sourceTokenised);\n    // Get the latest data to parse text against.\n\n    ajax.call([\n        {\n            methodname: \"local_mlangremover_get_field\",\n            args: {\n                data: [fielddata],\n            },\n            done: (data) => {\n                // The latests field text so multiple translators can work at the same time\n                // let fieldtext = data[0].text;\n\n                // Field text exists\n                if (data.length > 0) {\n                    // Updated hidden textarea with updatedtext\n                    let textarea = document.querySelector(\n                        Selectors.editors.multiples.textAreasResults\n                            .replace(\"<KEY>\", key));\n                    // Get the updated text\n                    // @todo here operate the removals\n                    // let updatedtext = getupdatedtext(fieldtext, text, sourceText, tempTranslations[key].sourceLang);\n                    // let updatedtext = fieldtext;\n\n                    // Build the data object\n                    let tdata = {};\n                    tdata.courseid = config.courseid;\n                    tdata.id = parseInt(id);\n                    // Tdata.tid = tid;\n                    tdata.table = table;\n                    tdata.field = field;\n                    tdata.text = updatedtext;\n                    tdata.cmid = cmid;\n                    info(tdata);\n                    // Success Message\n                    const successMessage = () => {\n                        log(\"SUCCES\");\n                        // Element.classList.add(\"local_deepler__success\");\n                        // Add saved indicator\n                        // setIconStatus(key, Selectors.statuses.success);\n                        // Remove success message after a few seconds\n                        /* setTimeout(() => {\n                             let multilangPill = document.querySelector(replaceKey(Selectors.statuses.multilang, key));\n                             let prevTransStatus = document.querySelector(replaceKey(Selectors.statuses.prevTransStatus, key));\n                             prevTransStatus.classList = \"badge badge-pill badge-success\";\n                             if (multilangPill.classList.contains(\"disabled\")) {\n                                 multilangPill.classList.remove('disabled');\n                             }\n                             // setIconStatus(key, Selectors.statuses.saved);\n                         });*/\n                    };\n                    // Error Mesage\n                    const errorMessage = (err) => {\n                        error(err);\n                    };\n                    // Submit the request\n                    ajax.call([\n                        {\n                            methodname: \"local_mlangremover_update_translation\",\n                            args: {\n                                data: [tdata],\n                            },\n                            done: (data) => {\n                                // Print response to console log\n                                info(\"ws: \", key, data);\n                                // Display success message\n                                if (data.length > 0) {\n                                    successMessage();\n                                    textarea.innerHTML = data[0].text;\n                                } else {\n                                    // Something went wrong with the data\n                                    errorMessage();\n                                }\n                            },\n                            fail: (err) => {\n                                // An error occurred\n                                errorMessage(err);\n                            },\n                        },\n                    ]);\n                } else {\n                    // Something went wrong with field retrieval\n                    warn(data);\n                }\n            },\n            fail: (err) => {\n                // An error occurred\n                error(err);\n            },\n        },\n    ]);\n};\n/**\n * @todo blank\n * @param {string} key\n */\nconst initTempForKey = (key) => {\n    // Get the source text\n    const sourceSelector = Selectors.sourcetexts.keys.replace(\"<KEY>\", key);\n    const sourceTextEncoded = document.querySelector(sourceSelector).getAttribute(\"data-sourcetext-raw\");\n    const sourceText = fromBase64(sourceTextEncoded);\n    const rmtag = removetag.checked;\n    let newText = '';\n    switch (removalMethod) {\n        case 'all' :\n            newText = extractLanguage(sourceText, selectedLanguages.length === 1 ? selectedLanguages[0] : 'other');\n            break;\n        case 'keepselected' :\n            if (rmtag) {\n                newText = extractLanguage(sourceText, selectedLanguages[0]);\n            } else {\n                newText = filterLanguagesWithTags(sourceText, selectedLanguages, true);\n            }\n            break;\n        case 'removeselected' :\n            newText = filterLanguagesWithTags(sourceText, selectedLanguages, false);\n            break;\n    }\n    log(removalMethod);\n    log(selectedLanguages);\n    log(sourceText);\n    log(newText);\n    // We make sure to initialize the record.\n    tempTranslations[key] = {\n        'old': sourceText,\n        'new': newText,\n    };\n};\n/**\n * Launch autotranslation\n */\nconst doTagRemoval = () => {\n    grabSetting();\n    /**/\n    document\n        .querySelectorAll(Selectors.statuses.checkedCheckBoxes)\n        .forEach((ckBox) => {\n            let key = ckBox.getAttribute(\"data-key\");\n            if (tempTranslations[key].editor !== null) {\n                initTempForKey(key);\n                saveToDB(key);\n            }\n        });\n    /**/\n};\n\nconst grabSetting = () => {\n    removalMethod = document.querySelector(Selectors.actions.removehow).value;\n    info(Selectors.statuses.selectedMLangCkboxes);\n    const allMlangSel = document.querySelectorAll(Selectors.statuses.selectedMLangCkboxes);\n    info(allMlangSel.length);\n    selectedLanguages = Array.from(document.querySelectorAll(Selectors.statuses.selectedMLangCkboxes))\n        .map(checkbox => checkbox.value);\n    if (allMlangSel.length !== 1 || removalMethod === 'removeselected') {\n        removetag.checked = false;\n        removetag.disabled = true;\n    } else if (allMlangSel.length === 1) {\n        removetag.disabled = false;\n    }\n};\n\n/**\n * Toggle checkboxes\n * @param {Event} e Event\n */\nconst toggleAllCheckboxes = (e) => {\n    // Check/uncheck checkboxes\n    if (e.target.checked) {\n        checkboxes.forEach((i) => {\n            // Toggle check box upon visibility\n            i.checked = !getParentRow(i).classList.contains('d-none');\n        });\n    } else {\n        checkboxes.forEach((i) => {\n            i.checked = false;\n        });\n    }\n    toggleAutotranslateButton();\n};\n\nconst getParentRow = (node) => {\n    return node.closest(replaceKey(Selectors.sourcetexts.parentrow, node.getAttribute('data-key')));\n};\n/**\n * Toggle Autotranslate Button\n */\nconst toggleAutotranslateButton = () => {\n    letsdobutton.disabled = true;\n    for (let i in checkboxes) {\n        let e = checkboxes[i];\n        if (e.checked) {\n            letsdobutton.disabled = false;\n            break;\n        }\n    }\n};\n\n/**\n * Simple helper to manage selectors\n * @param {string} s\n * @param {string} k\n * @returns {*}\n */\nconst replaceKey = (s, k) => {\n    return s.replace(\"<KEY>\", k);\n};\n\n/**\n * Helper function to decode the PHP base64 encoded source.\n * @param {string} encoded\n * @returns {string}\n */\nconst fromBase64 = (encoded) => {\n    const binString = atob(encoded); // Maybe we should import js-base64 instead.\n    const bytes = Uint8Array.from(binString, (m) => m.codePointAt(0));\n    return new TextDecoder().decode(bytes);\n};\n\n/**\n * As the title says.\n *\n * @param {string} t\n * @return {boolean}\n */\nconst hasMultilang = (t) => {\n    return t.includes('{mlang}');\n};\n\n/**\n * Extracts the text for a given language code from a multilang string, concatenating multiple instances.\n *\n * @param {string} textContent\n * @param {string} lang The language code to extract (e.g., 'en', 'fr', 'other').\n * @param {boolean} returnAllIfNotFound If true, returns the full text if the specified language is not found.\n * @return {string} The concatenated text for the specified language, or an empty string if not found.\n */\nconst extractLanguage = (textContent, lang, returnAllIfNotFound = true) => {\n    if (!hasMultilang(textContent)) {\n        return textContent;\n    }\n    // Define the pattern to match the specified language's multilang tags.\n    const pattern = new RegExp(`\\{mlang\\\\s+${lang}\\}(.*?)\\{mlang\\}`, 'gis');\n\n    // Initialize the result variable.\n    let result = '';\n\n    // Use matchAll to find all matches.\n    const matches = textContent.matchAll(pattern);\n    for (const match of matches) {\n        // Concatenate all the matched text segments.\n        result += `${match[1]} `;\n    }\n    // Trim any trailing whitespace.\n    result = result.trim();\n\n    // Return the concatenated text or an empty string if not found.\n    return result === '' && returnAllIfNotFound ? textContent : result;\n};\n\n/**\n * Filters the text to keep or remove specified languages, preserving their multilang tags.\n *\n * @param {string} textContent\n * @param {Array<string>} langs An array of language codes to keep or remove (e.g., ['en', 'fr', 'other']).\n * @param {boolean} keep If true, keeps only the specified languages; if false, removes the specified languages.\n * @return {string} The filtered text with the specified languages either kept or removed, preserving their tags.\n */\nconst filterLanguagesWithTags = (textContent, langs, keep = true) => {\n    if (!hasMultilang(textContent) || langs.length === 0) {\n        return textContent;\n    }\n    info(textContent, langs, keep);\n    // Define the pattern to match all multilang tags.\n    const pattern = /\\{mlang\\s+([a-z]{2}|other)\\}(.*?)\\{mlang\\}/gis;\n\n    // Initialize the result variable.\n    let result = '';\n\n    // Use matchAll to find all matches.\n    const matches = textContent.matchAll(pattern);\n    log(matches);\n    for (const match of matches) {\n        warn(match);\n        // Check if the language code is in the array of languages to keep or remove.\n        const inArray = langs.includes(match[1]);\n        if ((keep && inArray) || (!keep && !inArray)) {\n            // Append the text segment with its tags to the result.\n            result += `{mlang ${match[1]}}${match[2]}{mlang} `;\n        }\n    }\n    // Trim any trailing whitespace.\n    result = result.trim();\n\n    // Return the filtered text with tags.\n    return result === '' ? textContent : result;\n};\n"],"names":["tempTranslations","config","letsdobutton","checkboxes","selectedLanguages","allMLangs","removalMethod","removetag","log","a","warn","info","error","debug","cfg","window","console","bind","document","querySelector","Selectors","statuses","actions","selectAllBtn","checked","Array","from","querySelectorAll","allMLangCkboxes","length","checkBoxes","forEach","node","dataset","key","e","message","registerUI","addEventListener","target","closest","removeRadios","grabSetting","matches","allMLangCkboxesNames","doTagRemoval","toggleAllCheckboxes","toggleAutotranslateButton","ck","checkedCheckBoxes","ckBox","getAttribute","editor","sourceSelector","sourcetexts","keys","replace","sourceTextEncoded","sourceText","fromBase64","rmtag","newText","extractLanguage","filterLanguagesWithTags","initTempForKey","match","id","table","field","cmid","updatedtext","new","fielddata","courseid","parseInt","call","methodname","args","data","done","textarea","editors","multiples","textAreasResults","tdata","text","successMessage","errorMessage","err","innerHTML","fail","saveToDB","removehow","value","selectedMLangCkboxes","allMlangSel","map","checkbox","disabled","i","getParentRow","classList","contains","replaceKey","parentrow","s","k","encoded","binString","atob","bytes","Uint8Array","m","codePointAt","TextDecoder","decode","hasMultilang","t","includes","textContent","lang","returnAllIfNotFound","pattern","RegExp","result","matchAll","trim","langs","keep","inArray"],"mappings":"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"}